<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ekran TV</title>
    <link rel="icon" href="data:,">
    <link rel="manifest" href="/manifest.json">
    <script src="/socket.io/socket.io.js"></script>
    <!-- Fonty lokalne – aplikacja działa bez internetu -->
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            position: relative;
            background: radial-gradient(circle at center, #1a1a2e, #000);
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            z-index: -1;
            background: 
                radial-gradient(ellipse 70% 50% at 30% 30%, rgba(45, 55, 90, 0.85) 0%, transparent 55%),
                radial-gradient(ellipse 60% 70% at 70% 70%, rgba(80, 40, 100, 0.6) 0%, transparent 50%),
                radial-gradient(ellipse 80% 40% at 50% 20%, rgba(30, 60, 100, 0.5) 0%, transparent 45%),
                radial-gradient(ellipse 50% 80% at 10% 60%, rgba(100, 50, 80, 0.4) 0%, transparent 50%);
            animation: bgGradientFlow 12s ease-in-out infinite;
            pointer-events: none;
        }
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(125deg, 
                transparent 0%, 
                rgba(241, 196, 15, 0.03) 25%, 
                transparent 50%,
                rgba(52, 152, 219, 0.04) 75%,
                transparent 100%);
            background-size: 400% 400%;
            animation: bgShimmer 15s linear infinite;
            pointer-events: none;
        }
        @keyframes bgGradientFlow {
            0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
            25% { transform: translate(-8%, -5%) scale(1.08) rotate(1deg); }
            50% { transform: translate(5%, 8%) scale(0.95) rotate(-0.5deg); }
            75% { transform: translate(-4%, 4%) scale(1.05) rotate(0.8deg); }
        }
        @keyframes bgShimmer {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Animacja tła */
        @keyframes bgPulse {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
            100% { filter: brightness(1); }
        }
        .new-question-pulse { animation: bgPulse 0.5s ease-out; }

        /* Przycisk pełnego ekranu – prawy dolny róg, znika w fullscreen */
        #btn-fullscreen-screen {
            position: fixed; bottom: 20px; right: 20px; z-index: 10001;
            width: 52px; height: 52px; border-radius: 50%;
            background: rgba(0,0,0,0.5); border: 2px solid rgba(255,255,255,0.35);
            color: #fff; cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 26px; transition: opacity 0.2s, transform 0.2s; backdrop-filter: blur(8px);
        }
        #btn-fullscreen-screen:hover { background: rgba(0,0,0,0.7); transform: scale(1.08); opacity: 1; }
        #btn-fullscreen-screen:active { transform: scale(0.98); }

        #main-content {
            display: flex; flex-direction: column; width: 100%; height: 100%;
            position: relative; z-index: 10;
        }

        /* HEADER – przezroczysty, tło animowane z body prześwieca (jedna płaszczyzna) */
        .header {
            min-height: 15vh;
            display: flex; align-items: center; justify-content: space-between;
            background: linear-gradient(to bottom, rgba(0,0,0,0.2) 0%, rgba(0,0,0,0.08) 70%, transparent 100%);
            border-bottom: 1px solid rgba(255,255,255,0.06);
            padding: 15px 40px; 
            box-shadow: none;
            gap: 20px;
        }
        
        /* Timer badge w nagłówku – stała szerokość, żeby treść pytania się nie przesuwała przy odliczaniu */
        .header-timer {
            flex-shrink: 0;
            width: 90px;
            min-width: 90px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
        }
        
        /* Liczba graczy w nagłówku */
        .header-users {
            flex-shrink: 0;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
        
        /* Pytanie w środku nagłówka */
        .header-question {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            min-width: 0;
            padding: 0 20px;
        }
        
        .question-text {
            font-size: 2.5vw; text-transform: uppercase; font-weight: 900;
            text-shadow: 0 4px 15px rgba(0,0,0,0.8);
            background: linear-gradient(to bottom, #fff, #ddd);
            background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            line-height: 1.3; transition: transform 0.3s;
            word-wrap: break-word;
            overflow-wrap: break-word;
            hyphens: auto;
            max-width: 100%;
            margin: 0;
        }
        
        /* Obsługa wieloliniowych pytań */
        .question-text.multi-line {
            line-height: 1.4;
        }
        
        .question-text.two-lines {
            font-size: 2.2vw;
        }
        
        .question-text.three-lines {
            font-size: 2vw;
            line-height: 1.5;
        }
        
        /* Responsywność dla mniejszych ekranów */
        @media (max-width: 1200px) {
            .header {
                padding: 12px 30px;
                gap: 15px;
            }
            .question-text {
                font-size: 2.2vw;
            }
            .question-text.two-lines {
                font-size: 2vw;
            }
            .question-text.three-lines {
                font-size: 1.8vw;
            }
        }
        
        @media (max-width: 768px) {
            .header {
                padding: 10px 20px;
                gap: 10px;
                min-height: 12vh;
            }
            .header-timer {
                width: 72px;
                min-width: 72px;
            }
            .header-users {
                min-width: 60px;
            }
            .question-text {
                font-size: 1.8vw;
            }
            .question-text.two-lines {
                font-size: 1.6vw;
            }
            .question-text.three-lines {
                font-size: 1.4vw;
            }
            #timer-badge {
                font-size: clamp(0.8rem, 1.5vw, 1rem);
                padding: 6px 10px;
                width: 58px;
                min-width: 58px;
            }
            .header-users-counter {
                font-size: clamp(0.8rem, 1.5vw, 1rem);
                padding: 6px 12px;
            }
        }
        @keyframes titlePulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }
        
        @keyframes questionPop {
            0% { transform: scale(0.8); opacity: 0; }
            60% { transform: scale(1.05); opacity: 1; }
            100% { transform: scale(1); }
        }
        .animate-question { animation: questionPop 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        .estimation-screen-msg { font-size: clamp(1.2rem, 3vw, 2rem); color: rgba(255,255,255,0.9); text-align: center; padding: 40px 20px; display: flex; align-items: center; justify-content: center; width: 100%; }
        .estimation-result-box { 
            background: rgba(255,255,255,0.1); 
            border-radius: 16px; 
            padding: 28px 32px; 
            text-align: center; 
            max-width: 100%; 
            width: 100%;
            margin: 0 auto; 
            border: 2px solid rgba(255,255,255,0.2);
            box-sizing: border-box;
        }
        .estimation-correct { font-size: clamp(1.8rem, 5vw, 3rem); font-weight: 900; color: #2ecc71; margin-bottom: 16px; }
        .estimation-correct-label { 
            font-size: clamp(0.95rem, 2.5vw, 1.2rem); 
            color: rgba(255,255,255,0.8); 
            margin-bottom: 20px; 
        }
        .estimation-stats { display: flex; flex-wrap: wrap; gap: 10px 16px; justify-content: center; margin-top: 16px; }
        .estimation-stat-tag { background: rgba(255,255,255,0.15); padding: 8px 14px; border-radius: 20px; font-size: clamp(0.9rem, 2.5vw, 1.1rem); font-weight: 700; }
        
        /* Wykres poziomy dla estymacji */
        .estimation-chart-container {
            width: 100%;
            padding: 20px 0;
        }
        .estimation-chart {
            position: relative;
            width: 100%;
            margin: 30px 0 20px 0;
        }
        .estimation-chart-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            font-weight: 700;
            color: rgba(255,255,255,0.9);
        }
        .chart-label-min, .chart-label-max {
            font-weight: 900;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        .estimation-chart-track {
            position: relative;
            width: 100%;
            height: 200px;
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
            padding: 10px;
            box-sizing: border-box;
        }
        .estimation-chart-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(to right, rgba(255,255,255,0.3), rgba(255,255,255,0.5), rgba(255,255,255,0.3));
            transform: translateY(-50%);
            border-radius: 2px;
        }
        .estimation-bar {
            position: absolute;
            bottom: 50%;
            width: 8px;
            min-width: 4px;
            background: linear-gradient(to top, #3498db, #2980b9);
            border-radius: 4px 4px 0 0;
            transform: translateX(-50%);
            transition: all 0.3s;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.4);
        }
        .estimation-bar:hover {
            transform: translateX(-50%) scaleX(1.5);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.6);
        }
        .estimation-bar-value {
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(0.75rem, 2vw, 0.9rem);
            font-weight: 700;
            color: rgba(255,255,255,0.9);
            white-space: nowrap;
            margin-bottom: 4px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        .estimation-bar-count {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(0.7rem, 1.8vw, 0.85rem);
            font-weight: 600;
            color: rgba(255,255,255,0.8);
            white-space: nowrap;
            margin-top: 4px;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }
        .estimation-correct-marker {
            position: absolute;
            top: 50%;
            width: 4px;
            height: 30px;
            background: #2ecc71;
            transform: translate(-50%, -50%);
            border-radius: 2px;
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.8);
            z-index: 10;
        }
        .estimation-correct-marker::before {
            content: '✓';
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            color: #2ecc71;
            font-size: 1.2rem;
            font-weight: 900;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        /* Wyśrodkowanie bloku wyników estymacji i komunikatu na ekranie */
        .quiz-grid:has(.estimation-result-box),
        .quiz-grid:has(.estimation-screen-msg),
        .quiz-grid:has(.playoff-screen-grid) {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }
        .word-cloud { display: flex; flex-wrap: wrap; gap: 12px 24px; justify-content: center; align-items: center; padding: 30px; width: 100%; }
        .word-cloud-item { color: #fff; font-weight: 800; text-shadow: 0 2px 8px rgba(0,0,0,0.6); }
        .playoff-screen-grid { 
            display: flex; 
            width: 100%; 
            max-width: 900px; 
            min-height: 140px; 
            border-radius: 20px; 
            overflow: hidden; 
            box-shadow: 0 12px 40px rgba(0,0,0,0.5), 
                        0 4px 12px rgba(0,0,0,0.3),
                        inset 0 1px 0 rgba(255,255,255,0.1); 
            flex-shrink: 0;
            border: 2px solid rgba(255,255,255,0.15);
            backdrop-filter: blur(10px);
            background: rgba(0,0,0,0.2);
        }
        .playoff-card { 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            padding: 24px 20px; 
            flex: 1; 
            min-width: 0; 
            min-height: 120px;
            position: relative;
            transition: all 0.3s ease;
            border-right: 2px solid rgba(255,255,255,0.1);
        }
        .playoff-card:last-child {
            border-right: none;
        }
        .playoff-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        .playoff-card:hover::before {
            opacity: 1;
        }
        .playoff-card .playoff-label { 
            font-size: clamp(1.5rem, 4vw, 2.5rem); 
            font-weight: 900; 
            margin-bottom: 6px;
            text-shadow: 0 3px 10px rgba(0,0,0,0.5),
                         0 1px 3px rgba(0,0,0,0.8);
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        .playoff-card .playoff-count { 
            font-size: clamp(1rem, 2.5vw, 1.4rem); 
            opacity: 0.95;
            margin-top: 4px;
            text-shadow: 0 2px 6px rgba(0,0,0,0.5);
            font-weight: 600;
        }
        .playoff-card .playoff-pct { 
            font-size: clamp(1.4rem, 3.5vw, 2.2rem); 
            font-weight: 800; 
            margin-top: 4px;
            text-shadow: 0 2px 8px rgba(0,0,0,0.6),
                         0 1px 2px rgba(0,0,0,0.8);
        }
        .playoff-tak { 
            background: linear-gradient(135deg, #1976d2, #2196f3, #42a5f5); 
            color: #fff;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2),
                        0 4px 20px rgba(33, 150, 243, 0.4);
        }
        .playoff-nie { 
            background: linear-gradient(135deg, #c62828, #e74c3c, #ef5350); 
            color: #fff;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.2),
                        0 4px 20px rgba(231, 76, 60, 0.4);
        }

        /* CONTENT */
        .content-area {
            flex: 1; display: flex; flex-direction: column; padding: 30px;
            overflow: hidden; align-items: center; justify-content: center; position: relative;
        }
        
        /* Dla VOTE z obrazkiem - odpowiedzi na dole */
        .content-area.has-vote-image {
            justify-content: flex-start;
        }
        
        .content-area.has-vote-image .quiz-grid {
            margin-top: auto;
            padding-top: 20px;
        }
        
        /* HERO IMAGE – wejście z animacją */
        #hero-image-container {
            width: 100%; max-width: 100%; display: none;
            align-items: center; justify-content: center; margin-bottom: 16px;
            overflow: hidden; border-radius: 15px;
            visibility: visible !important;
            opacity: 1 !important;
            position: relative;
            z-index: 5;
            min-height: 0;
        }
        #hero-image-container.hero-reveal {
            animation: heroReveal 0.5s ease-out;
        }
        #hero-image-container.hero-reveal #hero-image {
            animation: heroImageReveal 0.55s ease-out 0.05s backwards;
        }
        @keyframes heroReveal {
            from { opacity: 0; transform: scale(0.96); }
            to { opacity: 1; transform: scale(1); }
        }
        @keyframes heroImageReveal {
            from { opacity: 0; transform: scale(0.92); }
            to { opacity: 1; transform: scale(1); }
        }
        
        /* Obrazek dla QUIZ – dopasowanie do dostępnej przestrzeni (większy na pełnym ekranie) */
        #hero-image-container:not(.vote-mode) {
            flex: 1;
            min-height: 180px;
            max-height: 78vh;
        }
        
        /* Obrazek dla VOTE - większy, odpowiedzi na dole */
        #hero-image-container.vote-mode {
            flex: 1;
            min-height: 360px;
            max-height: 82vh;
        }
        
        /* Gdy obrazek jest widoczny – zajmuje dostępną przestrzeń, grid na dole */
        .content-area:has(#hero-image-container[style*="flex"]) .quiz-grid {
            flex: 0 0 auto;
            min-height: 0;
        }
        
        /* Dla VOTE z obrazkiem - odpowiedzi na dole */
        .content-area:has(#hero-image-container.vote-mode[style*="flex"]) {
            justify-content: flex-start;
        }
        
        .content-area:has(#hero-image-container.vote-mode[style*="flex"]) .quiz-grid {
            margin-top: auto;
            padding-top: 20px;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        #hero-image {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
            border-radius: 15px; 
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            margin: 0 auto;
        }
        
        /* Obrazek dla QUIZ – wypełnia kontener (kontener ma flex:1 i max-height: 78vh) */
        #hero-image-container:not(.vote-mode) #hero-image {
            width: 100%;
            height: 100%;
            min-height: 0;
            object-fit: contain;
        }
        
        /* Obrazek dla VOTE – wypełnia kontener */
        #hero-image-container.vote-mode #hero-image {
            width: 100%;
            height: 100%;
            min-height: 0;
            object-fit: contain;
        }
        
        /* Upewnij się że obrazek zawsze jest widoczny gdy kontener jest widoczny */
        #hero-image-container[style*="flex"] #hero-image,
        #hero-image-container[style*="block"] #hero-image {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        /* Gdy hero jest widoczny (block/flex) – wyśrodkuj obrazek (np. estymacja) */
        #hero-image-container[style*="display: block"],
        #hero-image-container[style*="display: flex"] {
            display: flex !important;
            justify-content: center !important;
            align-items: center !important;
        }

        /* GRID */
        .quiz-grid {
            display: grid; width: 100%; flex: 1; gap: 25px;
            perspective: 1000px;
            min-height: 0;
        }
        
        /* Dla pytań typu SHIPS - wymuś display: block aby uniknąć konfliktu z display: grid */
        /* WAŻNE: Dodaj z-index aby plansza była nad cieniami i marginesami header */
        .quiz-grid.ships-mode {
            display: block !important;
            position: relative;
            z-index: 20;
        }
        .grid-4 { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }
        .grid-5 { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr 0.8fr; }
        .grid-5 .qc-e { grid-column: 1 / -1; }
        
        .grid-vote-text {
            display: flex; width: 100%; gap: 40px;
            align-items: flex-end; flex-shrink: 0;
        }
        
        /* Dla VOTE bez obrazka - standardowa wysokość */
        .grid-vote-text:not(.has-image) {
            height: 25vh !important;
            padding-bottom: 8vh;
        }
        
        /* Dla VOTE z obrazkiem - odpowiedzi na dole, mniejsza wysokość */
        .grid-vote-text.has-image {
            height: auto !important;
            min-height: 15vh;
            padding-bottom: 2vh;
            margin-top: auto;
        }
        
        /* Miejsce na pasek procentowy pod odpowiedziami (VOTE, VOTE_IMG) */
        .content-area:has(.grid-vote-text) {
            padding-bottom: 12vh !important;
        }
        
        .grid-vote-text .q-card { 
            flex: 1; 
            height: 100%;
            min-height: 80px;
        }
        
        /* HOT_OR_NOT - układ obrazków */
        .grid-hot-or-not {
            display: grid;
            width: 100%;
            gap: 30px;
            flex: 1;
            min-height: 400px;
            padding-bottom: 2vh;
        }
        
        /* Układ poziomy - dwa obrazki obok siebie */
        .grid-hot-or-not.layout-horizontal {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr;
            gap: 40px;
        }
        
        /* Układ pionowy - dwa obrazki jeden pod drugim */
        .grid-hot-or-not.layout-vertical {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 40px;
        }
        
        /* Układ mieszany - jeden pionowy, drugi poziomy (kwadratowy układ) */
        .grid-hot-or-not.layout-mixed {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr;
            gap: 40px;
            align-items: stretch;
        }
        
        /* Dla layoutu mieszanego, upewnij się że obrazy są wyświetlane w całości */
        .grid-hot-or-not.layout-mixed .hot-image-wrapper {
            min-height: 400px;
        }
        
        /* Karta obrazka HOT_OR_NOT */
        .hot-image-card {
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(20px);
            border: 3px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            cursor: pointer;
            transition: all 0.3s;
            min-height: 400px;
            height: 100%;
        }
        
        .hot-image-card:hover {
            transform: scale(1.02);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .hot-image-card.is-correct {
            border-color: #2ecc71;
            box-shadow: 0 0 30px rgba(46, 204, 113, 0.5);
        }
        
        .hot-image-card.is-wrong {
            border-color: #e74c3c;
            opacity: 0.6;
        }
        
        .hot-image-wrapper {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            min-height: 300px;
            width: 100%;
        }
        
        .hot-image-wrapper img {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* Ukryj fallback "Brak obrazka" gdy obrazek jest załadowany */
        .hot-image-wrapper:has(img[src]:not([src=""])) > div {
            display: none !important;
        }
        
        .hot-image-label {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 2vw;
            font-weight: 900;
            text-transform: uppercase;
            z-index: 10;
            backdrop-filter: blur(10px);
        }
        
        .hot-image-card.qc-a .hot-image-label {
            background: rgba(52, 152, 219, 0.9);
        }
        
        .hot-image-card.qc-b .hot-image-label {
            background: rgba(231, 76, 60, 0.9);
        }
        
        .hot-image-answer {
            padding: 25px;
            background: rgba(0, 0, 0, 0.7);
            text-align: center;
            font-size: 2vw;
            font-weight: 700;
            color: white;
            text-transform: uppercase;
            flex-shrink: 0;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-top: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        /* HOT_OR_NOT - poprawka dla battle bar */
        .content-area:has(.grid-hot-or-not) {
            padding-bottom: 10vh !important;
        }
        
        .grid-hot-or-not {
            margin-bottom: 2vh;
        }
        
        /* Statystyki dla HOT_OR_NOT */
        .hot-image-stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 50px;
            font-size: 2.5vw;
            font-weight: 900;
            z-index: 10;
            backdrop-filter: blur(10px);
        }

        /* Animacja tła kart (jak przyciski na vote – gradient flow w kolorze karty) */
        @keyframes answerBtnFlow {
            0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); opacity: 1; }
            25% { transform: translate(-3%, -2%) scale(1.06) rotate(0.5deg); opacity: 0.95; }
            50% { transform: translate(2%, 3%) scale(0.97) rotate(-0.3deg); opacity: 1; }
            75% { transform: translate(-2%, 2%) scale(1.03) rotate(0.4deg); opacity: 0.98; }
        }

        /* CARDS */
        .q-card {
            background: rgba(255, 255, 255, 0.08); backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 20px;
            display: flex; align-items: center; padding: 0 30px; position: relative;
            overflow: hidden; box-shadow: 0 6px 22px rgba(0,0,0,0.45);
            width: 100%; height: 100%;
            
            /* Domyślnie widoczne */
            opacity: 1; 
            transform: translateY(0) rotateX(0);
            
            /* Transition dla hover */
            transition: transform 0.3s, box-shadow 0.3s, opacity 0.5s, filter 0.5s, border-color 0.5s;
        }
        .q-card .q-letter,
        .q-card .q-text,
        .q-card .q-result-bar { position: relative; z-index: 2; }
        
        /* Animacja wejścia */
        @keyframes cardEnter { 
            from { opacity: 0; transform: translateY(40px) rotateX(15deg); }
            to { opacity: 1; transform: translateY(0) rotateX(0); } 
        }
        
        .run-animation .q-card { 
            opacity: 0; /* Ukryj przed startem animacji */
            animation: cardEnter 0.6s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; 
        }
        
        /* ZWIĘKSZONE OPÓŹNIENIA (efekt 1, 2, 3...) */
        .run-animation .q-card:nth-child(1) { animation-delay: 0.2s; }
        .run-animation .q-card:nth-child(2) { animation-delay: 0.4s; }
        .run-animation .q-card:nth-child(3) { animation-delay: 0.6s; }
        .run-animation .q-card:nth-child(4) { animation-delay: 0.8s; }
        .run-animation .q-card:nth-child(5) { animation-delay: 1.0s; }
        
        .q-card:hover { transform: scale(1.02); }
        
        /* Warstwa animowana + pasek + cień w kolorze karty */
        .q-card::before {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            width: 100%; height: 100%;
            z-index: 0;
            border-radius: inherit;
            pointer-events: none;
        }
        .qc-a {
            border-left: 15px solid #3498db;
            box-shadow: 0 6px 22px rgba(0,0,0,0.45), 0 0 28px -4px rgba(52, 152, 219, 0.5);
        }
        .qc-a::before {
            background: linear-gradient(to right, rgba(52, 152, 219, 0.15) 0%, transparent 20%),
                radial-gradient(ellipse 70% 50% at 20% 50%, rgba(52, 152, 219, 0.4) 0%, transparent 55%),
                radial-gradient(ellipse 60% 70% at 80% 50%, rgba(52, 152, 219, 0.25) 0%, transparent 50%);
            animation: answerBtnFlow 10s ease-in-out infinite;
            box-shadow: inset 0 0 40px rgba(52, 152, 219, 0.06);
        }
        .qc-b {
            border-left: 15px solid #e74c3c;
            box-shadow: 0 6px 22px rgba(0,0,0,0.45), 0 0 28px -4px rgba(231, 76, 60, 0.5);
        }
        .qc-b::before {
            background: linear-gradient(to right, rgba(231, 76, 60, 0.15) 0%, transparent 20%),
                radial-gradient(ellipse 70% 50% at 20% 50%, rgba(231, 76, 60, 0.4) 0%, transparent 55%),
                radial-gradient(ellipse 60% 70% at 80% 50%, rgba(231, 76, 60, 0.25) 0%, transparent 50%);
            animation: answerBtnFlow 10s ease-in-out infinite;
            box-shadow: inset 0 0 40px rgba(231, 76, 60, 0.06);
        }
        .qc-c {
            border-left: 10px solid #f1c40f;
            box-shadow: 0 6px 22px rgba(0,0,0,0.45), 0 0 28px -4px rgba(241, 196, 15, 0.5);
        }
        .qc-c::before {
            background: linear-gradient(to right, rgba(241, 196, 15, 0.15) 0%, transparent 20%),
                radial-gradient(ellipse 70% 50% at 20% 50%, rgba(241, 196, 15, 0.4) 0%, transparent 55%),
                radial-gradient(ellipse 60% 70% at 80% 50%, rgba(241, 196, 15, 0.25) 0%, transparent 50%);
            animation: answerBtnFlow 10s ease-in-out infinite;
            box-shadow: inset 0 0 40px rgba(241, 196, 15, 0.06);
        }
        .qc-d {
            border-left: 10px solid #2ecc71;
            box-shadow: 0 6px 22px rgba(0,0,0,0.45), 0 0 28px -4px rgba(46, 204, 113, 0.5);
        }
        .qc-d::before {
            background: linear-gradient(to right, rgba(46, 204, 113, 0.15) 0%, transparent 20%),
                radial-gradient(ellipse 70% 50% at 20% 50%, rgba(46, 204, 113, 0.4) 0%, transparent 55%),
                radial-gradient(ellipse 60% 70% at 80% 50%, rgba(46, 204, 113, 0.25) 0%, transparent 50%);
            animation: answerBtnFlow 10s ease-in-out infinite;
            box-shadow: inset 0 0 40px rgba(46, 204, 113, 0.06);
        }
        .qc-e {
            border-left: 10px solid #9b59b6;
            box-shadow: 0 6px 22px rgba(0,0,0,0.45), 0 0 28px -4px rgba(155, 89, 182, 0.5);
        }
        .qc-e::before {
            background: linear-gradient(to right, rgba(155, 89, 182, 0.15) 0%, transparent 20%),
                radial-gradient(ellipse 70% 50% at 20% 50%, rgba(155, 89, 182, 0.4) 0%, transparent 55%),
                radial-gradient(ellipse 60% 70% at 80% 50%, rgba(155, 89, 182, 0.25) 0%, transparent 50%);
            animation: answerBtnFlow 10s ease-in-out infinite;
            box-shadow: inset 0 0 40px rgba(155, 89, 182, 0.06);
        }

        .q-letter {
            font-size: 3vw; font-weight: 900; margin-right: 25px;
            background: rgba(0,0,0,0.4); min-width: 5vw; height: 5vw;
            display: flex; align-items: center; justify-content: center;
            border-radius: 12px; z-index: 5; box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
        }
        .q-text { font-size: 2.2vw; font-weight: 700; flex: 1; text-shadow: 0 2px 4px rgba(0,0,0,0.8); z-index: 5; }
        
        .q-result-bar {
            position: absolute; bottom: 0; left: 0; height: 100%;
            background: linear-gradient(90deg, rgba(255,255,255,0.1), rgba(255,255,255,0.25));
            width: 0%; transition: width 1s ease-out; z-index: 1;
        }

        /* STANY ODPOWIEDZI */
        .show-correct .q-card { opacity: 0.3 !important; filter: grayscale(1); transform: scale(0.98); }
        .show-correct .q-card.is-correct {
            opacity: 1 !important; filter: none; transform: scale(1.05); z-index: 10;
            background: rgba(46, 204, 113, 0.2); border: 4px solid #2ecc71;
            box-shadow: 0 0 80px rgba(46, 204, 113, 0.5);
        }

        /* BATTLE BAR */
        #live-battle-bar-container {
            position: absolute; bottom: 2vh; left: 5%; width: 90%; height: 8vh;
            background: linear-gradient(to right, #c0392b, #e74c3c); border-radius: 50px;
            overflow: hidden; display: none; box-shadow: 0 10px 30px rgba(0,0,0,0.7), inset 0 5px 10px rgba(0,0,0,0.3);
            border: 4px solid rgba(255, 255, 255, 0.2); z-index: 50;
        }
        
        /* HOT_OR_NOT - większy padding na dole aby odpowiedzi były widoczne */
        .content-area:has(.grid-hot-or-not) {
            padding-bottom: 12vh !important;
        }
        
        .grid-hot-or-not .hot-image-answer {
            font-size: 2vw;
            padding: 25px 20px;
            min-height: 80px;
        }
        #live-battle-bar-fill {
            height: 100%; width: 50%; background: linear-gradient(to right, #2980b9, #3498db);
            transition: width 0.5s ease-out; position: relative; border-right: 2px solid rgba(255,255,255,0.8);
            box-shadow: 5px 0 15px rgba(0,0,0,0.5);
        }
        .battle-score {
            position: absolute; top: 50%; transform: translateY(-50%);
            font-size: 5vw !important; font-weight: 900; z-index: 20; text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }
        .score-a { left: 20px; color: #fff; }
        .score-b { right: 20px; color: #fff; }

        /* OVERLAYS – przejście przy pokazywaniu */
        .overlay-screen {
            position: absolute; top:0; left:0; width:100%; height:100%; z-index: 100;
            display: none; flex-direction: column; align-items: center; justify-content: center;
            background: radial-gradient(circle at bottom, #2c3e50, #000);
        }
        .overlay-screen[style*="display: flex"],
        .overlay-screen.overlay-visible {
            animation: overlayFadeIn 0.4s ease-out;
        }
        @keyframes overlayFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .intro-title {
            font-size: 6vw; font-weight: 900; background: -webkit-linear-gradient(#f1c40f, #e67e22);
            background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin-bottom: 40px;
            filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
            text-shadow: 0 2px 8px rgba(0,0,0,0.4);
            animation: introTitlePulse 3s ease-in-out infinite;
        }
        @keyframes introTitlePulse {
            0%, 100% { transform: scale(1); filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5)) brightness(1); }
            50% { transform: scale(1.08); filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5)) brightness(1.25); }
        }

        /* LEADERBOARD */
        .lb-row {
            display: flex; justify-content: space-between; width: 70%;
            background: rgba(255,255,255,0.05); padding: 15px 40px; margin: 10px 0;
            border-radius: 20px; font-size: 2.5vw; font-weight: bold; border-left: 8px solid #f1c40f;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); transition: transform 0.3s;
        }
        .lb-row:nth-child(1) { transform: scale(1.05); background: rgba(241, 196, 15, 0.1); border-color: #ffd700; }
        .lb-row:nth-child(2) { border-color: #c0c0c0; }
        .lb-row:nth-child(3) { border-color: #cd7f32; }

        /* QR */
        .qr-container { display: flex; flex-direction: row; flex-wrap: wrap; gap: 24px; align-items: center; justify-content: center; margin-top: 20px; }
        .qr-wrapper { display: flex; flex-direction: row; gap: 40px; align-items: center; justify-content: center; flex-wrap: wrap;
            background: rgba(52, 152, 219, 0.2); padding: 30px 40px; border-radius: 20px;
            backdrop-filter: blur(10px); border: 2px solid rgba(52, 152, 219, 0.4);
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
        }
        .qr-lub { font-size: 2.5vw; font-weight: 900; color: rgba(255,255,255,0.9); text-transform: uppercase; letter-spacing: 4px; margin: 8px 0; }
        .qr-box {
            display: flex; flex-direction: column; align-items: center;
            background: rgba(255, 255, 255, 0.08); padding: 24px; border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }
        .qr-num { display: inline-block; width: 1.4em; height: 1.4em; line-height: 1.3; text-align: center; background: rgba(255,255,255,0.3); border-radius: 50%; margin-right: 6px; font-size: 0.9em; }
        .qr-label {
            font-size: 2vw; font-weight: 700; text-transform: uppercase; margin-bottom: 15px; letter-spacing: 2px;
        }
        .qr-label.wifi { color: #3498db; text-shadow: 0 0 20px rgba(52, 152, 219, 0.8); }
        .qr-label.local { color: #2ecc71; text-shadow: 0 0 20px rgba(46, 204, 113, 0.8); }
        .qr-label.tunnel { color: #9b59b6; text-shadow: 0 0 20px rgba(155, 89, 182, 0.8); }
        .qr-label.admin { color: #e67e22; text-shadow: 0 0 20px rgba(230, 126, 34, 0.8); }
        .qr-box-lte-info { background: rgba(231, 76, 60, 0.25); border: 2px solid rgba(231, 76, 60, 0.5); color: #ecf0f1; padding: 20px; border-radius: 12px; text-align: center; font-size: 1.1rem; }
        .intro-editor-btn {
            display: inline-block; flex-shrink: 0; margin-top: 16px; padding: 14px 28px;
            background: #3498db; color: #fff !important; text-decoration: none; font-weight: bold;
            border-radius: 12px; font-size: clamp(1rem, 2vw, 1.3rem); box-shadow: 0 4px 15px rgba(52, 152, 219, 0.5);
            transition: background 0.2s, transform 0.2s; border: 2px solid rgba(255,255,255,0.4);
        }
        .intro-editor-btn:hover { background: #2980b9; transform: scale(1.05); color: #fff !important; }
        .intro-admin-btn { background: #e67e22 !important; box-shadow: 0 4px 15px rgba(230, 126, 34, 0.5); }
        .intro-admin-btn:hover { background: #d35400 !important; color: #fff !important; }
        .intro-start-btn { background: #2ecc71 !important; box-shadow: 0 4px 15px rgba(46, 204, 113, 0.5); border: 2px solid rgba(255,255,255,0.4); cursor: pointer; font: inherit; }
        .intro-start-btn:hover { background: #27ae60 !important; color: #fff !important; transform: scale(1.05); }
        .qr-image {
            width: 250px; height: 250px; border-radius: 15px; border: 5px solid white;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }
        .qr-wifi-info { margin-top: 15px; text-align: center; font-size: 1.2vw; color: rgba(255, 255, 255, 0.7); }
        .qr-wifi-info strong { color: #3498db; font-size: 1.4vw; }

        /* PODIUM */
        .pod-column {
            display: flex; flex-direction: column; align-items: center; justify-content: flex-end;
            margin: 0 1.5vw; width: 25vw; height: 75%; position: relative; perspective: 1000px;
        }
        .pod-bar {
            width: 100%; height: 0%; transition: height 1s cubic-bezier(0.34, 1.56, 0.64, 1);
            border-radius: 15px 15px 0 0; display: flex; align-items: flex-end; justify-content: center;
            padding-bottom: 20px; position: relative;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.4), 10px 10px 30px rgba(0,0,0,0.5);
            border-right: 1px solid rgba(255,255,255,0.3); border-top: 1px solid rgba(255,255,255,0.5);
        }
        .pod-bar::after {
            content: ''; position: absolute; top: 0; right: -15px; width: 15px; height: 100%;
            background: rgba(0,0,0,0.3); transform-origin: left; transform: skewY(-45deg); z-index: -1;
            border-radius: 0 10px 0 0;
        }
        .pod-name {
            font-size: 3.5vw; font-weight: 900; text-transform: uppercase; position: absolute;
            bottom: 100%; width: 200%; text-align: center; margin-bottom: 25px;
            text-shadow: 0 5px 15px rgba(0,0,0,1); white-space: nowrap; left: -50%;
            opacity: 0; transition: all 0.5s ease-out; transform: translateY(20px);
        }
        .pod-name.visible { opacity: 1; transform: translateY(0); }
        .pod-score {
            font-size: 3vw; font-weight: 900; color: white; position: absolute; bottom: -90px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.8); opacity: 0; transition: opacity 0.5s; text-align: center;
        }
        .pod-score.visible { opacity: 1; }
        .pod-correct { font-size: 1.5vw; color: #ddd; font-weight: 700; display: block; margin-top: 5px; opacity: 0.8; }
        .bar-1 { background: linear-gradient(135deg, #f1c40f, #f39c12); }
        .bar-2 { background: linear-gradient(135deg, #bdc3c7, #7f8c8d); }
        .bar-3 { background: linear-gradient(135deg, #e67e22, #d35400); }
        .name-1 { color: #f1c40f; } .name-2 { color: #bdc3c7; } .name-3 { color: #e67e22; }
        .pod-place {
            font-size: 6vw; font-weight: 900; color: rgba(0,0,0,0.2); position: absolute;
            bottom: 10px; user-select: none;
        }
        
        /* Karty podium dla trybu drużynowego (poziomo) */
        .podium-team-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 40px 60px;
            border-radius: 25px;
            margin: 0 40px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 30px rgba(0,0,0,0.5);
            border: 3px solid rgba(255,255,255,0.1);
            min-width: 400px;
            max-width: 500px;
            opacity: 0;
            transform: scale(0.8) translateY(30px);
            transition: all 0.8s cubic-bezier(0.68, -0.55, 0.27, 1.55);
        }
        
        .podium-team-card.revealed {
            opacity: 1 !important;
            transform: scale(1) translateY(0) !important;
            display: flex !important;
            visibility: visible !important;
            flex-direction: column !important;
            align-items: center !important;
            justify-content: center !important;
        }
        
        /* Wymuś widoczność kart w trybie drużynowym */
        #podium:has(.podium-team-card.revealed) .podium-team-card.revealed {
            display: flex !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        .podium-card-title {
            font-size: clamp(1.5rem, 3vw, 2.5rem);
            margin-bottom: 20px;
            color: rgba(255,255,255,0.9);
            font-weight: 800;
            text-align: center;
        }
        
        .podium-card-name {
            font-size: clamp(2rem, 4vw, 3.5rem);
            font-weight: 900;
            margin-bottom: 15px;
            color: white;
            text-align: center;
            text-transform: uppercase;
            text-shadow: 0 4px 15px rgba(0,0,0,0.8);
        }
        
        .podium-card-score {
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 900;
            text-align: center;
        }
        
        /* Nagłówek PODIUM – wielkość jak nazwa quizu na starcie */
        .podium-title {
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
            text-align: center !important;
            font-size: 6vw !important;
            font-weight: 900 !important;
            margin-bottom: 20px !important;
            background: -webkit-linear-gradient(#f1c40f, #e67e22) !important;
            background-clip: text !important; -webkit-background-clip: text !important;
            -webkit-text-fill-color: transparent !important;
            width: 100%;
            padding: 0 20px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.35);
            filter: drop-shadow(0 4px 12px rgba(0,0,0,0.4));
        }
        
        .podium-card-2 {
            background: linear-gradient(135deg, rgba(127, 140, 141, 0.2), rgba(189, 195, 199, 0.2));
            border-color: #bdc3c7;
            box-shadow: 0 0 40px rgba(189, 195, 199, 0.3);
        }
        
        .podium-card-2 .podium-card-name {
            color: #bdc3c7;
        }
        
        .podium-card-2 .podium-card-score {
            color: #bdc3c7;
        }
        
        .podium-card-1 {
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.2), rgba(241, 196, 15, 0.2));
            border-color: #f1c40f;
            box-shadow: 0 0 40px rgba(241, 196, 15, 0.4);
        }
        
        .podium-card-1 .podium-card-name {
            background: -webkit-linear-gradient(#f1c40f, #e67e22);
            background-clip: text; -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .podium-card-1 .podium-card-score {
            background: -webkit-linear-gradient(#f1c40f, #e67e22);
            background-clip: text; -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* COUNTER */
        /* Online counter - ukryty (przeniesiony do nagłówka) */
        .online-counter {
            display: none;
        }

        /* TIMER */
        .timer-overlay { position: absolute; top: 20px; left: 20px; width: 100px; height: 100px; z-index: 30; display: none !important; visibility: hidden !important; }
        .timer-text {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);
            font-weight: 900; font-size: 35px; color: #f1c40f;
        }
        svg circle {
            fill: none; stroke: #f1c40f; stroke-width: 8; stroke-linecap: round;
            transform: rotate(-90deg); transform-origin: 50% 50%;
            filter: drop-shadow(0 0 5px rgba(241, 196, 15, 0.8));
        }
        
        /* TIMER BADGE (jak w vote.html) - w nagłówku, stała szerokość żeby nie przesuwać pytania */
        #timer-badge {
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.3);
            color: #f1c40f;
            padding: 8px 12px;
            border-radius: 50px;
            font-weight: 800;
            font-size: clamp(1rem, 2vw, 1.3rem);
            backdrop-filter: blur(5px);
            display: none;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            white-space: nowrap;
            width: 72px;
            min-width: 72px;
            box-sizing: border-box;
            text-align: center;
        }
        
        #timer-badge #time-left {
            color: #f1c40f;
            transition: color 0.3s;
        }
        
        #timer-badge #time-left.warning {
            color: #e74c3c;
        }
        #timer-badge.timer-urgent {
            animation: timerPulse 0.8s ease-in-out infinite;
        }
        #timer-badge.timer-urgent #time-left {
            color: #ff6b6b !important;
        }
        @keyframes timerPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
            50% { transform: scale(1.12); box-shadow: 0 0 20px rgba(231, 76, 60, 0.6); }
        }
        
        /* Liczba graczy w nagłówku */
        .header-users-counter {
            background: rgba(0,0,0,0.6);
            color: #0f0;
            padding: 8px 16px;
            border-radius: 50px;
            font-weight: bold;
            font-size: clamp(1rem, 2vw, 1.3rem);
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid #0f0;
            backdrop-filter: blur(5px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        
        .header-users-counter .dot {
            width: 10px;
            height: 10px;
            background: #0f0;
            border-radius: 50%;
            box-shadow: 0 0 8px #0f0;
            animation: dotPulse 1s infinite;
        }
        
        @keyframes dotPulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* CONFETTI */
        #confetti-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            z-index: 9999; overflow: hidden;
        }
        .confetti {
            position: absolute; top: -20px; width: 12px; height: 12px; border-radius: 2px;
            opacity: 0.9; animation: confetti-fall linear forwards; z-index: 9999;
        }
        @keyframes confetti-fall {
            0% { transform: translateY(0) rotate(0deg); opacity: 1; }
            100% { transform: translateY(120vh) rotate(720deg); opacity: 0.3; }
        }
        /* Dłuższa animacja confetti - około 5 sekund */
        .confetti {
            animation-duration: 5s !important;
        }
        .lb-correct-count { font-size: 1.5vw; color: #aaa; margin-right: 15px; font-weight: normal; }
    

        /* TEAM BATTLE – WYNIK DRUŻYNOWY (LEADERBOARD) */
        #team-score-display {
            display: flex;
            gap: 40px;
            justify-content: center;
            align-items: center;
            margin: 40px 0;
        }
        .team-score-card {
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            min-width: 300px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            border: 4px solid rgba(255,255,255,0.15);
        }
        .team-a-card {
            background: linear-gradient(135deg, #3498db, #2980b9);
            border-color: #2980b9;
        }
        .team-b-card {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            border-color: #c0392b;
        }
        .team-score-name {
            font-size: 2.5vw;
            font-weight: 900;
            color: white;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-shadow: 0 4px 15px rgba(0,0,0,0.8);
        }
        .team-score-value {
            font-size: 5vw;
            font-weight: 900;
            color: white;
            text-shadow: 0 6px 20px rgba(0,0,0,0.8);
        }

    </style>
</head>
<body>

    <div id="confetti-container"></div>

    <button type="button" id="btn-fullscreen-screen" title="Pełny ekran" aria-label="Pełny ekran">⛶</button>

    <div id="intro-screen" class="overlay-screen">
        <div class="intro-title" id="intro-txt">Imprezja Quiz</div>
        <div id="qr-box-admin-wrap" class="qr-container" style="margin-bottom: 20px; display: none;">
            <div id="qr-box-admin" class="qr-box">
                <div class="qr-label admin">PANEL ADMINA</div>
                <img id="qr-admin" class="qr-image" src="" alt="QR Admin">
                <div id="qr-admin-url" class="qr-wifi-info" style="margin-top: 8px; font-size: 0.85rem; word-break: break-all; color: #95a5a6;"></div>
                <a href="/editor.html" target="_blank" rel="noopener" id="btn-editor-intro" class="intro-editor-btn">✏️ Edytor pytań</a>
                <div class="qr-wifi-info" style="margin-top: 12px;"><strong>Zeskanuj telefonem/tabletem – zniknie po wejściu</strong></div>
                <div class="qr-wifi-info" style="margin-top: 8px;">Telefon i komputer w tej samej sieci WiFi.</div>
                <div style="margin-top: 16px; display: flex; flex-wrap: wrap; gap: 12px; justify-content: center; align-items: center;">
                    <a href="/admin.html" target="_blank" rel="noopener" id="btn-admin-intro" class="intro-editor-btn intro-admin-btn">Panel admina na tym komputerze</a>
                    <button type="button" id="btn-rozpocznij-intro" class="intro-editor-btn intro-start-btn">Rozpocznij</button>
                </div>
            </div>
        </div>
        <div class="qr-container" id="qr-main-container">
            <div id="qr-wrapper" class="qr-wrapper" style="display: none;">
                <div id="qr-box-wifi" class="qr-box" style="display: none;">
                    <div class="qr-label wifi"><span class="qr-num">1</span> SIEĆ Wi-Fi</div>
                    <img id="qr-wifi" class="qr-image" src="" alt="QR WiFi">
                    <div class="qr-wifi-info" id="wifi-info"><strong>Zeskanuj aby połączyć</strong></div>
                </div>
                <div id="qr-box-local" class="qr-box" style="display: none;">
                    <div class="qr-label local"><span class="qr-num">2</span> GRA (Wi‑Fi)</div>
                    <img id="qr-local" class="qr-image" src="" alt="QR Gra lokalna">
                    <div class="qr-wifi-info"><strong>Zeskanuj – sieć lokalna</strong></div>
                </div>
            </div>
            <div id="qr-lub" class="qr-lub" style="display: none;">LUB</div>
            <div id="qr-box-tunnel" class="qr-box" style="display: none;">
                <div class="qr-label tunnel">GRA (LTE)</div>
                <img id="qr-tunnel" class="qr-image" src="" alt="QR Tunel">
                <div class="qr-wifi-info"><strong>Alternatywa – sieć komórkowa</strong></div>
            </div>
            <div id="qr-box-lte-info" class="qr-box qr-box-lte-info" style="display: none;">
                <strong>Gra przez LTE</strong><br>
                Organizator musi kliknąć <strong style="color: #e74c3c;">czerwony przycisk</strong> „Uruchom tunel" w panelu admina.
            </div>
        </div>
        <div style="margin-top: 24px;">
            <a href="/start.html" class="intro-editor-btn" style="background:#555; color:#fff;">← Cofnij</a>
        </div>
    </div>

    <!-- Ekran "Zaraz zaczynamy" – pokazywany po kliknięciu Rozpocznij; zawiera QR kody jeśli były wcześniej wygenerowane -->
    <div id="zaraz-zaczynamy-overlay" class="overlay-screen" style="display: none; z-index: 9999;">
        <div class="intro-title" style="font-size: clamp(2rem, 10vw, 6rem); margin-bottom: 20px;">Zaraz zaczynamy</div>
        <div id="zaraz-qr-container" class="qr-container" style="display: none; flex-wrap: wrap; justify-content: center; gap: 20px;">
            <div id="zaraz-qr-wrapper" class="qr-wrapper" style="display: none;">
                <div id="zaraz-qr-wifi" class="qr-box" style="display: none;">
                    <div class="qr-label wifi"><span class="qr-num">1</span> SIEĆ Wi-Fi</div>
                    <img id="zaraz-qr-wifi-img" class="qr-image" src="" alt="QR WiFi">
                    <div class="qr-wifi-info"><strong>Zeskanuj aby połączyć</strong></div>
                </div>
                <div id="zaraz-qr-local" class="qr-box" style="display: none;">
                    <div class="qr-label local"><span class="qr-num">2</span> GRA (Wi‑Fi)</div>
                    <img id="zaraz-qr-local-img" class="qr-image" src="" alt="QR Gra lokalna">
                    <div class="qr-wifi-info"><strong>Zeskanuj – sieć lokalna</strong></div>
                </div>
            </div>
            <div id="zaraz-qr-lub" class="qr-lub" style="display: none;">LUB</div>
            <div id="zaraz-qr-tunnel" class="qr-box" style="display: none;">
                <div class="qr-label tunnel">GRA (LTE)</div>
                <img id="zaraz-qr-tunnel-img" class="qr-image" src="" alt="QR Tunel">
                <div class="qr-wifi-info"><strong>Alternatywa – sieć komórkowa</strong></div>
            </div>
            <div id="zaraz-qr-lte-info" class="qr-box qr-box-lte-info" style="display: none;">
                <strong>Gra przez LTE</strong><br>
                Organizator musi kliknąć <strong style="color: #e74c3c;">czerwony przycisk</strong> „Uruchom tunel" w panelu admina.
            </div>
        </div>
    </div>

    <div id="leaderboard" class="overlay-screen">
        <h1 id="lb-title" style="font-size: 5vw; color:#f1c40f; margin-bottom:30px; text-transform:uppercase; font-weight:900; text-shadow: 0 2px 8px rgba(0,0,0,0.5), 0 0 30px rgba(241,196,15,0.5);">TOP 10 GRACZY</h1>
        <div id="lb-list" style="width:100%; display:flex; flex-direction:column; align-items:center;"></div>

        <!-- Wynik drużynowy (Team Battle) – pokazywany zamiast TOP 10 gdy teamBattleMode === true -->
        <div id="team-score-display" style="display:none;">
            <div class="team-score-card team-a-card">
                <div class="team-score-name" id="screen-team-name-a">Team Pan Młody</div>
                <div class="team-score-value" id="screen-team-score-a">0</div>
            </div>
            <div class="team-score-card team-b-card">
                <div class="team-score-name" id="screen-team-name-b">Team Pani Młoda</div>
                <div class="team-score-value" id="screen-team-score-b">0</div>
            </div>
        </div>

    </div>

    <div id="podium" class="overlay-screen" style="flex-direction:column; align-items:center; justify-content:center; padding-bottom:10vh;">
        <!-- Nagłówek PODIUM -->
        <div id="podium-title-header" class="podium-title" style="display: block; visibility: visible; opacity: 1; text-align: center; font-size: 6vw; font-weight: 900; margin-bottom: 20px; background: -webkit-linear-gradient(#f1c40f, #e67e22); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent;">
            🏆 PODIUM
        </div>
        
        <!-- Kontener dla kart/słupków (poziomo) -->
        <div id="podium-content-container" style="display: flex; flex-direction: row; align-items: center; justify-content: center; width: 100%;">
        <!-- Karty dla trybu drużynowego (poziomo: 2. miejsce z lewej, 1. miejsce z prawej) -->
        <div id="podium-team-card-2" class="podium-team-card podium-card-2" style="display:none;">
            <h2 class="podium-card-title">🥈 2. MIEJSCE</h2>
            <div id="nick-2-team" class="podium-card-name"></div>
            <div id="score-2-team" class="podium-card-score"></div>
        </div>
        <div id="podium-team-card-1" class="podium-team-card podium-card-1" style="display:none;">
            <h2 class="podium-card-title">🥇 1. MIEJSCE</h2>
            <div id="nick-1-team" class="podium-card-name"></div>
            <div id="score-1-team" class="podium-card-score"></div>
        </div>
        
        <!-- Słupki dla trybu indywidualnego (używamy prostych identyfikatorów jak w starym pliku) -->
        <div class="pod-column" id="pod-column-2">
            <div class="pod-bar bar-2" id="bar-2">
                <div id="nick-2" class="pod-name name-2"></div>
                <div class="pod-place">2</div>
                <div class="pod-score" id="score-2"></div>
            </div>
        </div>
        <div class="pod-column" id="pod-column-1">
            <div class="pod-bar bar-1" id="bar-1">
                <div id="nick-1" class="pod-name name-1"></div>
                <div class="pod-place">1</div>
                <div class="pod-score" id="score-1"></div>
            </div>
        </div>
        <div class="pod-column" id="pod-column-3">
            <div class="pod-bar bar-3" id="bar-3">
                <div id="nick-3" class="pod-name name-3"></div>
                <div class="pod-place">3</div>
                <div class="pod-score" id="score-3"></div>
            </div>
        </div>
        </div>
    </div>

    <!-- EKRAN PODZIĘKOWAŃ -->
    <div id="thanks" class="overlay-screen" style="display: none;">
        <div class="thanks-title-screen" id="thanks-title-screen" style="font-size: clamp(3rem, 10vw, 6rem); font-weight: 900; margin-bottom: 40px; text-align: center; background: -webkit-linear-gradient(#f1c40f, #e67e22); -webkit-background-clip: text; -webkit-text-fill-color: transparent; line-height: 1.2;">Imprezja Quiz</div>
        <div class="thanks-content-screen" id="thanks-content-screen" style="font-size: clamp(1.5rem, 5vw, 3rem); color: rgba(255, 255, 255, 0.9); margin-bottom: 40px; line-height: 1.6; max-width: 1200px; margin-left: auto; margin-right: auto; text-align: center;">Dziękuję za udział w zabawie</div>
        <div class="thanks-image-container-screen" id="thanks-image-container-screen" style="display: none; text-align: center; margin-top: 40px;">
            <img id="thanks-image-screen" src="" alt="Podziękowania" style="max-width: 90vw; max-height: 70vh; border-radius: 20px; box-shadow: 0 15px 50px rgba(0,0,0,0.6); object-fit: contain;">
        </div>
    </div>

    <!-- Online counter - ukryty (przeniesiony do nagłówka) -->
    <div class="online-counter">
        <div class="dot"></div>
        <span id="user-count">0</span>
    </div>

    <!-- STARY KOŁOWY TIMER - UKRYTY (używamy tylko badge) -->
    <div class="timer-overlay" id="timer-circle" style="display: none !important; visibility: hidden !important;">
        <svg width="100" height="100">
            <circle id="timer-path" cx="50" cy="50" r="45" stroke-dasharray="283"></circle>
        </svg>
        <div class="timer-text" id="timer-val"></div>
    </div>

    <audio id="audio-music"></audio>
    <audio id="audio-sfx"></audio>
    <audio id="audio-clock" loop></audio>
    <audio id="audio-podium" loop></audio>

    <div id="main-content">
        <div class="header">
            <div class="header-timer">
                <div id="timer-badge">⏱ <span id="time-left">30</span></div>
            </div>
            <div class="header-question">
                <div class="question-text" id="main-q">...</div>
            </div>
            <div class="header-users">
                <div class="header-users-counter">
                    <div class="dot"></div>
                    <span id="user-count-header">0</span>
                </div>
            </div>
        </div>
        <div class="content-area" id="content-area">
            <div id="hero-image-container">
                <img id="hero-image" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="" onerror="console.error('❌ HTML onerror - src:', this.src); this.style.display='none';">
            </div>
            <div id="quiz-grid" class="quiz-grid"></div>

            <div id="live-battle-bar-container">
                <div class="battle-score score-a" id="score-val-a">0</div>
                <div id="live-battle-bar-fill"></div>
                <div class="battle-score score-b" id="score-val-b">0</div>
            </div>
        </div>
    </div>

    <script>
        const socket = io();
        let timerInt;
        let timerBadgeInterval = null;
        
        // Ukryj stary kołowy timer na początku
        window.addEventListener('DOMContentLoaded', () => {
            const oldTimer = document.getElementById('timer-circle');
            if(oldTimer) {
                oldTimer.style.display = 'none';
                oldTimer.style.visibility = 'hidden';
            }
        });
        let currentMode = 'QUIZ';

        const musicPlayer = document.getElementById('audio-music');
        const sfxPlayer = document.getElementById('audio-sfx');
        const clockPlayer = document.getElementById('audio-clock');
        const podiumPlayer = document.getElementById('audio-podium');
        let audioEnabled = false;
        let currentPodiumStep = -1;
        let wakeLock = null;
        let lastStateType = null;
        let lastQuestionId = null;

        // Wake Lock – ekran prowadzącego nie gaśnie w trakcie rozgrywki
        async function requestWakeLock() {
            if (!('wakeLock' in navigator) || document.visibilityState !== 'visible') return;
            try {
                if (wakeLock) try { wakeLock.release(); } catch (e) {}
                wakeLock = await navigator.wakeLock.request('screen');
            } catch (e) {}
        }
        document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') requestWakeLock(); });
        if (document.visibilityState === 'visible') requestWakeLock();

        // ========================
        // AUDIO
        // ========================
        // Minimalny cichy WAV – odtwarzany przy pierwszym kliku, żeby przeglądarka odblokowała audio (play() bez src nie odblokowuje)
        const SILENT_WAV = 'data:audio/wav;base64,UklGRjIAAABXQVZFZm10IBIAAAABAAEAQB8AAEAfAAABAAgAAABmYWN0BAAAAAAAAABkYXRhAAAAAA==';
        async function initAudioContext() {
            audioEnabled = true;
            function unlock(el) {
                try {
                    el.src = SILENT_WAV;
                    el.play().then(function() { el.pause(); }).catch(function(){});
                } catch(e) {}
            }
            unlock(sfxPlayer);
            unlock(musicPlayer);
            unlock(clockPlayer);
            if(podiumPlayer) unlock(podiumPlayer);
            try { document.documentElement.requestFullscreen().catch(()=>{}); } catch(e){}
            requestWakeLock();
            // Ponów żądanie QR
            socket.emit('request_qr');
            socket.emit('request_qr_wifi');
            socket.emit('request_qr_local');
            socket.emit('request_qr_admin');
        }
        // Upewnij się że funkcja jest dostępna globalnie
        window.initAudioContext = initAudioContext;

        // Przywrócenie dźwięku: pierwsza interakcja (klik lub dotyk) odblokowuje dźwięk – ale nie przy linkach do admina/edytora (żeby nie włączać fullscreen zamiast otwarcia linku)
        (function() {
            function onInteraction(e) {
                var t = e && e.target;
                if (t && (t.closest('a[href="/admin.html"]') || t.closest('a[href="/editor.html"]'))) return;
                if (!audioEnabled) {
                    initAudioContext();
                    document.removeEventListener('click', onInteraction);
                    document.removeEventListener('touchstart', onInteraction);
                }
            }
            document.addEventListener('click', onInteraction, { passive: true });
            document.addEventListener('touchstart', onInteraction, { passive: true });
        })();

        // Przycisk pełnego ekranu – klik = wejście w fullscreen + odblokowanie dźwięku; znika gdy już fullscreen
        (function() {
            const btn = document.getElementById('btn-fullscreen-screen');
            if (!btn) return;
            function updateFullscreenButton() {
                btn.style.display = document.fullscreenElement ? 'none' : 'flex';
            }
            btn.addEventListener('click', function() {
                if (!document.fullscreenElement) {
                    initAudioContext();
                }
                updateFullscreenButton();
            });
            document.addEventListener('fullscreenchange', updateFullscreenButton);
            updateFullscreenButton();
        })();

        // Admin na tym komputerze – nie ukrywaj QR po otwarciu (flaga ustawiana przy kliknięciu)
        document.getElementById('btn-admin-intro')?.addEventListener('click', function() { window._adminOpenedFromScreen = true; });

        // Rozpocznij – pokaż ekran "Zaraz zaczynamy" i dopiero wtedy zamknij QR admina (komp i telefon mogły mieć panel równocześnie)
        function syncZarazQRCodes() {
            const wifiImg = document.getElementById('qr-wifi');
            const localImg = document.getElementById('qr-local');
            const tunnelImg = document.getElementById('qr-tunnel');
            const zarazWrapper = document.getElementById('zaraz-qr-wrapper');
            const zarazLub = document.getElementById('zaraz-qr-lub');
            const zarazWifi = document.getElementById('zaraz-qr-wifi');
            const zarazLocal = document.getElementById('zaraz-qr-local');
            const zarazTunnel = document.getElementById('zaraz-qr-tunnel');
            const zarazLteInfo = document.getElementById('zaraz-qr-lte-info');
            const zarazWifiImg = document.getElementById('zaraz-qr-wifi-img');
            const zarazLocalImg = document.getElementById('zaraz-qr-local-img');
            const zarazTunnelImg = document.getElementById('zaraz-qr-tunnel-img');
            const zarazContainer = document.getElementById('zaraz-qr-container');
            const state = currentGameState;
            const hasWifiOrLocal = state && (state.hasWifi || state.showLocalGameQR);
            let hasAny = false;
            if (zarazWrapper) zarazWrapper.style.display = hasWifiOrLocal ? 'flex' : 'none';
            if (hasWifiOrLocal) hasAny = true;
            if (zarazLub) zarazLub.style.display = hasWifiOrLocal ? 'block' : 'none';
            if (wifiImg && wifiImg.src && zarazWifi && zarazWifiImg) {
                zarazWifiImg.src = wifiImg.src;
                zarazWifi.style.display = (state && state.hasWifi) ? 'flex' : 'none';
            }
            if (localImg && localImg.src && zarazLocal && zarazLocalImg) {
                zarazLocalImg.src = localImg.src;
                zarazLocal.style.display = (state && state.showLocalGameQR) ? 'flex' : 'none';
            }
            if (tunnelImg && tunnelImg.src && zarazTunnel && zarazTunnelImg) {
                zarazTunnelImg.src = tunnelImg.src;
                zarazTunnel.style.display = (state && state.tunnelUrl) ? 'flex' : 'none';
                if (zarazTunnel.style.display === 'flex') hasAny = true;
            }
            if (zarazLteInfo) {
                zarazLteInfo.style.display = (state && !state.tunnelUrl && hasWifiOrLocal) ? 'flex' : 'none';
                if (zarazLteInfo.style.display === 'flex') hasAny = true;
            }
            if (zarazContainer) zarazContainer.style.display = hasAny ? 'flex' : 'none';
        }
        document.getElementById('btn-rozpocznij-intro')?.addEventListener('click', function() {
            window._adminOpenedFromScreen = false;
            const wrap = document.getElementById('qr-box-admin-wrap');
            if (wrap) wrap.style.display = 'none';
            const el = document.getElementById('zaraz-zaczynamy-overlay');
            syncZarazQRCodes();
            if (el) el.style.display = 'flex';
        });

        function stopAllAudio() {
            musicPlayer.pause(); musicPlayer.currentTime=0;
            sfxPlayer.pause(); sfxPlayer.currentTime=0;
            clockPlayer.pause(); clockPlayer.currentTime=0;
            if(podiumPlayer) { podiumPlayer.pause(); podiumPlayer.currentTime=0; }
        }
        function playPodiumMusic() {
            if(!audioEnabled || !podiumPlayer) return;
            if(!podiumPlayer.paused) return;
            podiumPlayer.src = '/uploads/sfx/podjum.mp3';
            podiumPlayer.volume = 0.8;
            podiumPlayer.play().catch(e => console.error('Podium Error:', e));
        }
        function stopPodiumMusic() {
            if(podiumPlayer) { podiumPlayer.pause(); podiumPlayer.currentTime=0; }
        }
        
        function updateTimerFromServer(timeLeft) {
            const display = document.getElementById('time-left');
            const timerBadge = document.getElementById('timer-badge');
            
            if (!display || !timerBadge) return;
            
            const time = Math.max(0, Math.floor(timeLeft));
            display.textContent = time;
            
            if (time <= 5) {
                display.classList.add('warning');
                timerBadge.classList.add('timer-urgent');
            } else {
                display.classList.remove('warning');
                timerBadge.classList.remove('timer-urgent');
            }
        }

        function triggerHeroReveal() {
            const c = document.getElementById('hero-image-container');
            if (!c) return;
            c.classList.remove('hero-reveal');
            void c.offsetHeight;
            c.classList.add('hero-reveal');
            setTimeout(function() { c.classList.remove('hero-reveal'); }, 600);
        }

        // --- POPRAWIONE NAZWY PLIKÓW (Z PODKREŚLNIKAMI) ---
        function playSFX(name) {
            if(!audioEnabled)return;
            // Dźwięki w uploads/sfx/
            sfxPlayer.src = `/uploads/sfx/${name}.mp3`;
            sfxPlayer.play().catch(e => console.error("SFX Error:", e));
        }

        function playMusic(url) {
            console.log('🎵 playMusic wywołane:', {
                url: url,
                audioEnabled: audioEnabled,
                currentSrc: musicPlayer.src,
                isPaused: musicPlayer.paused
            });
            
            if(!audioEnabled) {
                console.log('🔇 playMusic - audio wyłączone, pomijam');
                return;
            }
            
            // WAŻNE: Popraw ścieżkę jeśli potrzeba (dodaj /uploads/ jeśli brakuje)
            let fullUrl = url;
            if(url && !url.startsWith('/') && !url.startsWith('http')) {
                fullUrl = '/uploads/' + url;
            }
            
            // Sprawdź czy to ten sam plik i czy już gra
            const currentSrc = musicPlayer.src;
            const isSameFile = currentSrc && (currentSrc.includes(url) || currentSrc.includes(fullUrl));
            if(isSameFile && !musicPlayer.paused) {
                console.log('🔇 playMusic - ten sam plik już gra, pomijam:', url);
                return;
            }
            
            console.log('🎵 playMusic - zatrzymuję wszystkie dźwięki i odtwarzam:', fullUrl);
            stopAllAudio();
            musicPlayer.src = fullUrl;
            musicPlayer.play().catch((e) => {
                console.error('❌ Błąd odtwarzania muzyki:', e, 'URL:', fullUrl);
            });
        }

        function playClock() {
            if(!audioEnabled)return;
            if(!clockPlayer.paused)return;
            if(!sfxPlayer.paused){sfxPlayer.pause();sfxPlayer.currentTime=0;}
            // Zegar w uploads/sfx/
            clockPlayer.src = '/uploads/sfx/clock_loop.mp3';
            clockPlayer.volume = 0.2;
            clockPlayer.play().catch(e => console.error("Clock Error:", e));
        }

        // ========================
        // SOCKET OBSŁUGA
        // ========================
        
        socket.on('qr_code', (url) => {
            const img = document.getElementById('qr-tunnel');
            if (img) img.src = url || '';
            const el = document.getElementById('zaraz-zaczynamy-overlay');
            if (el && el.style.display === 'flex') syncZarazQRCodes();
        });

        socket.on('qr_local_game', (data) => {
            const img = document.getElementById('qr-local');
            if (img) img.src = (data && data.qrCode) ? data.qrCode : '';
            const el = document.getElementById('zaraz-zaczynamy-overlay');
            if (el && el.style.display === 'flex') syncZarazQRCodes();
        });

        socket.on('qr_admin', (data) => {
            const wrap = document.getElementById('qr-box-admin-wrap');
            const img = document.getElementById('qr-admin');
            const urlDisplay = document.getElementById('qr-admin-url');
            
            if (data && data.qrCode) {
                if (img) img.src = data.qrCode;
                if (urlDisplay && data.url) {
                    urlDisplay.textContent = data.url;
                    urlDisplay.style.display = 'block';
                }
                if (wrap) wrap.style.display = 'flex';
                console.log('✅ QR admin otrzymany, URL:', data.url);
            } else {
                if (img) img.src = '';
                if (urlDisplay) urlDisplay.textContent = '';
                if (wrap) wrap.style.display = 'none';
                console.warn('⚠️ QR admin nie został wygenerowany');
            }
        });
        socket.on('hide_admin_qr', () => {
            if (window._adminOpenedFromScreen) return;
            const wrap = document.getElementById('qr-box-admin-wrap');
            if (wrap) wrap.style.display = 'none';
        });

        socket.on('qr_wifi', (data) => {
            const img = document.getElementById('qr-wifi');
            if (img) img.src = data && data.qrCode ? data.qrCode : '';
            const info = document.getElementById('wifi-info');
            if (info) info.innerHTML = data && data.ssid ? '<strong>' + data.ssid + '</strong>' : '<strong>Zeskanuj aby połączyć</strong>';
            const el = document.getElementById('zaraz-zaczynamy-overlay');
            if (el && el.style.display === 'flex') syncZarazQRCodes();
        });

        socket.on('connect', () => {
            console.log("Connected");
            socket.emit('set_game_mode', 'quiz');
            socket.emit('request_qr');
            socket.emit('request_qr_wifi');
            socket.emit('request_qr_local');
            socket.emit('request_qr_admin');
        });

        socket.on('users_count', (c) => {
            const v = String(c);
            const userCountEl = document.getElementById('user-count');
            const headerEl = document.getElementById('user-count-header');
            if(userCountEl) userCountEl.innerText = v;
            if(headerEl) headerEl.innerText = v;
        });

        socket.on('stats_update', (stats) => {
            if(currentMode==='VOTE') {
                updateLiveBar(stats);
            }
        });

        socket.on('update_team_scores', (teams) => {
            if (teams && teams.A && teams.B) {
                const elScoreA = document.getElementById('screen-team-score-a');
                const elScoreB = document.getElementById('screen-team-score-b');
                const elNameA = document.getElementById('screen-team-name-a');
                const elNameB = document.getElementById('screen-team-name-b');
                
                if (elScoreA) elScoreA.innerText = teams.A.score || 0;
                if (elScoreB) elScoreB.innerText = teams.B.score || 0;
                if (elNameA && teams.A.name) elNameA.innerText = teams.A.name;
                if (elNameB && teams.B.name) elNameB.innerText = teams.B.name;
            }
        });

        function updateLiveBar(stats) {
            const valA = stats['A'] || 0;
            const valB = stats['B'] || 0;
            const total = valA + valB;
            let percA = 50;
            if(total>0) percA = (valA/total)*100;
            document.getElementById('live-battle-bar-fill').style.width = percA+'%';
            document.getElementById('score-val-a').innerText = Math.round(percA)+'%';
            document.getElementById('score-val-b').innerText = Math.round(100-percA)+'%';
        }

        // ========================
        // UPDATE STATE
        // ========================
        socket.on('update_state', (state) => {
            console.log("State update:", state.type);
            
            // Zaktualizuj currentGameState dla użycia w innych miejscach (np. ships_game_update)
            currentGameState = state;
            
            // Zaktualizuj śledzenie typu stanu (przed sprawdzeniem nowego pytania)
            const previousStateType = lastStateType;
            lastStateType = state.type;
            if(state.type !== 'PODIUM') stopPodiumMusic();
            
            const intro = document.getElementById('intro-screen');
            const pod = document.getElementById('podium');
            const lb = document.getElementById('leaderboard');
            const main = document.getElementById('main-content');
            const zarazOverlay = document.getElementById('zaraz-zaczynamy-overlay');
            if (zarazOverlay && (state.type === 'IDLE' || state.type === 'GAME' || state.type === 'GAME_STATS')) zarazOverlay.style.display = 'none';

            // Widoczność QR admina: pokazuj jeśli serwer każe LUB admin otwarty z komputera (nie zamykaj – komp+telefon jednocześnie). Zamyka dopiero przycisk Rozpocznij.
            const qrBoxAdminWrap = document.getElementById('qr-box-admin-wrap');
            if (qrBoxAdminWrap) qrBoxAdminWrap.style.display = (state.showAdminQR || window._adminOpenedFromScreen) ? 'flex' : 'none';
            // Widoczność QR: pole jednego koloru (1-WiFi, 2-Gra) → LUB → LTE (bez nr) lub info
            const qrWrapper = document.getElementById('qr-wrapper');
            const qrLub = document.getElementById('qr-lub');
            const qrBoxWifi = document.getElementById('qr-box-wifi');
            const qrBoxLocal = document.getElementById('qr-box-local');
            const qrBoxTunnel = document.getElementById('qr-box-tunnel');
            const qrBoxLteInfo = document.getElementById('qr-box-lte-info');
            const hasWifiOrLocal = state.hasWifi || state.showLocalGameQR;
            if (qrWrapper) qrWrapper.style.display = hasWifiOrLocal ? 'flex' : 'none';
            if (qrBoxWifi) qrBoxWifi.style.display = state.hasWifi ? 'flex' : 'none';
            if (qrBoxLocal) qrBoxLocal.style.display = state.showLocalGameQR ? 'flex' : 'none';
            if (qrLub) qrLub.style.display = hasWifiOrLocal ? 'block' : 'none';
            if (qrBoxTunnel) qrBoxTunnel.style.display = state.tunnelUrl ? 'flex' : 'none';
            if (qrBoxLteInfo) qrBoxLteInfo.style.display = (!state.tunnelUrl && hasWifiOrLocal) ? 'flex' : 'none';
            const zarazOverlayEl = document.getElementById('zaraz-zaczynamy-overlay');
            if (zarazOverlayEl && zarazOverlayEl.style.display === 'flex' && typeof syncZarazQRCodes === 'function') syncZarazQRCodes();

            // Aktualizuj liczbę graczy - zawsze gdy jest dostępna
            if (state.playersCount != null) {
                const v = String(state.playersCount);
                const userCountEl = document.getElementById('user-count');
                const headerEl = document.getElementById('user-count-header');
                if(userCountEl) userCountEl.innerText = v;
                if(headerEl) headerEl.innerText = v;
            }
            
            // Logi: połączenie 1/2 litery -> screen (czego brakuje)
            if (state.activeQuestion && state.activeQuestion.type === 'LETTER') {
                const lg = state.letterGame;
                const letterGameStarted = !!(lg && lg.gameStarted);
                if (letterGameStarted) {
                    console.log('🔤 [LETTER screen] OK: letterGame otrzymany, gameStarted=true');
                } else {
                    const missing = [];
                    if (!lg) missing.push('brak state.letterGame');
                    else if (lg.questionId !== state.activeQuestion.id) missing.push('letterGame.questionId!==activeQuestion.id');
                    else if (!lg.gameStarted) missing.push('letterGame.gameStarted=false');
                    console.log('🔤 [LETTER screen] Czego brakuje:', missing.join(', '), '| state.letterGame=', lg);
                }
            }

            if(state.type==='IDLE') {
                stopAllAudio();
                intro.style.display='flex';
                document.getElementById('intro-txt').innerText='Zaraz zaczynamy';
                pod.style.display='none';
                lb.style.display='none';
                main.style.display='none';
                // schowaj timer na pauzie
                clearInterval(timerInt);
                clearInterval(timerBadgeInterval);
                document.getElementById('timer-circle').style.display='none';
                document.getElementById('timer-badge').style.display='none';
                // Ukryj stary timer całkowicie
                const oldTimer = document.getElementById('timer-circle');
                if(oldTimer) {
                    oldTimer.style.display = 'none';
                    oldTimer.style.visibility = 'hidden';
                }
                clockPlayer.pause();
                return;
            }

            intro.style.display = state.type==='INTRO' ? 'flex':'none';
            pod.style.display = state.type==='PODIUM' ? 'flex':'none';
            lb.style.display = state.type==='LEADERBOARD' ? 'flex':'none';
            const thanksEl = document.getElementById('thanks');
            if (thanksEl) thanksEl.style.display = state.type==='THANKS' ? 'flex':'none';
            main.style.display = (state.type==='GAME' || state.type==='GAME_STATS') ? 'flex':'none';

            // UKRYJ TIMER we wszystkich stanach poza GAME
            if(state.type!=='GAME') {
                clearInterval(timerInt);
                clearInterval(timerBadgeInterval);
                const timerEl = document.getElementById('timer-circle');
                const timerBadge = document.getElementById('timer-badge');
                if(timerEl) {
                    timerEl.style.display='none';
                    timerEl.style.visibility='hidden';
                    timerEl.style.opacity='0';
                }
                if(timerBadge) {
                    timerBadge.style.display='none';
                }
                clockPlayer.pause();
            }

            // INTRO
            if(state.type==='INTRO') {
                document.getElementById('intro-txt').innerText = state.quizTitle || 'Imprezja Quiz';
                if(sfxPlayer.paused || !sfxPlayer.src.includes('intro_loop')) {
                    stopAllAudio();
                    playSFX('intro_loop');
                }
                return;
            }

            // LEADERBOARD
            if(state.type==='LEADERBOARD') {
                const list = document.getElementById('lb-list');
                const title = document.getElementById('lb-title');
                const teamBox = document.getElementById('team-score-display');

                // TEAM MODE: zamiast TOP 10 pokazujemy wynik drużyn
                if(state.teamBattleMode) {
                    if(title) title.innerText = 'WYNIK DRUŻYN';
                    if(list) { list.innerHTML = ''; list.style.display = 'none'; }
                    if(teamBox) teamBox.style.display = 'flex';

                    const nameA = (state.teams && state.teams.A && state.teams.A.name) ? state.teams.A.name : 'Team A';
                    const nameB = (state.teams && state.teams.B && state.teams.B.name) ? state.teams.B.name : 'Team B';
                    const scoreA = (state.teams && state.teams.A && state.teams.A.score != null) ? state.teams.A.score : 0;
                    const scoreB = (state.teams && state.teams.B && state.teams.B.score != null) ? state.teams.B.score : 0;
                    const countA = (state.teams && state.teams.A && state.teams.A.playerCount != null) ? state.teams.A.playerCount : 0;
                    const countB = (state.teams && state.teams.B && state.teams.B.playerCount != null) ? state.teams.B.playerCount : 0;

                    const elNameA = document.getElementById('screen-team-name-a');
                    const elNameB = document.getElementById('screen-team-name-b');
                    const elScoreA = document.getElementById('screen-team-score-a');
                    const elScoreB = document.getElementById('screen-team-score-b');

                    if(elNameA) elNameA.innerText = nameA;
                    if(elNameB) elNameB.innerText = nameB;
                    if(elScoreA) elScoreA.innerText = scoreA;
                    if(elScoreB) elScoreB.innerText = scoreB;
                } else {
                    if(title) title.innerText = 'TOP 10 GRACZY';
                    if(teamBox) teamBox.style.display = 'none';
                    if(list) list.style.display = 'flex';

                    if(list) list.innerHTML = '';
                    if(state.leaderboard && list) {
                        state.leaderboard.forEach((p, i) => {
                            const correctInfo = p.correctCount !== undefined ? 
                                `<span class="lb-correct-count">${p.correctCount}/${p.totalQuestions || 0}</span>` : '';
                            list.innerHTML += `
                                <div class="lb-row">
                                    <div>${i+1}. ${p.nick}</div>
                                    <div style="display:flex; align-items:center;">${correctInfo}${p.score}</div>
                                </div>
                            `;
                        });
                    }
                }

                if(list && !list.dataset.played) {
                    stopAllAudio();
                    playSFX('leaderboard');
                    list.dataset.played = 'true';
                }
                return;
            } else {
                document.getElementById('lb-list').dataset.played = '';
            }
            if(state.type!=='THANKS') {
                const thanksEl = document.getElementById('thanks');
                if(thanksEl) thanksEl.dataset.played = '';
            }

            // PODIUM
            if(state.type==='THANKS') {
                const thanksEl = document.getElementById('thanks');
                const titleEl = document.getElementById('thanks-title-screen');
                const contentEl = document.getElementById('thanks-content-screen');
                const imageContainer = document.getElementById('thanks-image-container-screen');
                const imageEl = document.getElementById('thanks-image-screen');
                
                if (thanksEl) thanksEl.style.display = 'flex';
                if (thanksEl && !thanksEl.dataset.played) {
                    stopAllAudio();
                    if (!audioEnabled) initAudioContext();
                    playSFX('podziekowanie');
                    thanksEl.dataset.played = 'true';
                }
                
                if (state.thanksScreen && (state.thanksScreen.text || state.thanksScreen.image)) {
                    // Użyj niestandardowego ekranu końcowego
                    if (titleEl) {
                        titleEl.textContent = state.quizTitle || 'Imprezja Quiz';
                    }
                    
                    if (state.thanksScreen.text) {
                        contentEl.textContent = state.thanksScreen.text;
                        contentEl.style.display = 'block';
                    } else {
                        contentEl.style.display = 'none';
                    }
                    
                    if (state.thanksScreen.image) {
                        const imgSrc = state.thanksScreen.image.startsWith('/') || state.thanksScreen.image.startsWith('http') 
                            ? state.thanksScreen.image 
                            : '/uploads/' + state.thanksScreen.image;
                        imageEl.src = imgSrc;
                        imageContainer.style.display = 'block';
                    } else {
                        imageContainer.style.display = 'none';
                    }
                } else {
                    // Domyślny ekran końcowy
                    if (titleEl) {
                        titleEl.textContent = state.quizTitle || 'Imprezja Quiz';
                    }
                    contentEl.textContent = 'Dziękuję za udział w zabawie';
                    contentEl.style.display = 'block';
                    imageContainer.style.display = 'none';
                }
                // NIE wywołuj stopAllAudio() tutaj – zatrzymałoby dźwięk podziękowań
            }
            if(state.type==='PODIUM') {
                // WYŁĄCZ TIMER NA PODIUM - TO JEST KLUCZOWA ZMIANA!
                clearInterval(timerInt);
                clearInterval(timerBadgeInterval);
                const timerEl = document.getElementById('timer-circle');
                const timerBadge = document.getElementById('timer-badge');
                if(timerEl) {
                    timerEl.style.display='none';
                    timerEl.style.visibility='hidden';
                    timerEl.style.opacity='0';
                }
                if(timerBadge) {
                    timerBadge.style.display='none';
                }
                clockPlayer.pause();
                if(previousStateType !== 'PODIUM') {
                    stopAllAudio();
                    playPodiumMusic();
                }

                // UPEWNIJ SIĘ ŻE PODIUM JEST WIDOCZNE
                if(pod) {
                    pod.style.setProperty('display', 'flex', 'important');
                    pod.style.setProperty('visibility', 'visible', 'important');
                    pod.style.setProperty('opacity', '1', 'important');
                    console.log('✅ Kontener podium ustawiony na widoczny');
                }

                const w = state.winners || [];
                const step = Number(state.podiumStep) || 0;
                const isTeam = !!state.teamBattleMode;

                console.log('PODIUM - step:', step, 'winners:', w, 'isTeam:', isTeam, 'pod display:', pod ? pod.style.display : 'null');

                // Ukryj kolumnę 3 w trybie drużynowym (nie usuwamy HTML)
                const bar3El = document.getElementById('bar-3');
                let col3 = null;
                if(bar3El && bar3El.parentElement && bar3El.parentElement.parentElement) {
                    col3 = bar3El.parentElement.parentElement;
                }
                if(isTeam && col3) col3.style.display = 'none';
                if(!isTeam && col3) col3.style.display = '';

                const getName = (p) => {
                    if(!p) return '-';
                    return isTeam ? (p.name || '-') : (p.nick || '-');
                };

                const getScoreText = (p) => {
                    if(!p) return '';
                    let html = `${p.score || 0}`;
                    if(!isTeam && p.correctCount!==undefined) html += `<div class="pod-correct">${p.correctCount}/${p.totalQuestions || 0}</div>`;
                    return html;
                };

                // Ustaw dane - dla trybu drużynowego będą użyte w kartach, dla indywidualnego w słupkach
                // WAŻNE: Ustawiamy dane tylko do właściwych elementów w zależności od trybu
                if(!isTeam) {
                    // Tryb indywidualny - ustaw dane do słupków (nick-1, nick-2, nick-3)
                    const nick1El = document.getElementById('nick-1');
                    const score1El = document.getElementById('score-1');
                    const nick2El = document.getElementById('nick-2');
                    const score2El = document.getElementById('score-2');
                    const nick3El = document.getElementById('nick-3');
                    const score3El = document.getElementById('score-3');
                    
                    if(nick1El) nick1El.innerText = getName(w[0]);
                    if(score1El) score1El.innerHTML = getScoreText(w[0]);
                    if(nick2El) nick2El.innerText = getName(w[1]);
                    if(score2El) score2El.innerHTML = getScoreText(w[1]);
                    if(nick3El) nick3El.innerText = (w[2] && w[2].nick) ? w[2].nick : '-';
                    if(score3El) score3El.innerHTML = getScoreText(w[2]);
                }
                // Dla trybu drużynowego dane są ustawiane później w sekcji isTeam

                const b1 = document.getElementById('bar-1'),
                      b2 = document.getElementById('bar-2'),
                      b3 = document.getElementById('bar-3');
                // Używamy prostych identyfikatorów (jak w starym pliku)
                const els1 = [document.getElementById('nick-1'), document.getElementById('score-1')],
                      els2 = [document.getElementById('nick-2'), document.getElementById('score-2')],
                      els3 = [document.getElementById('nick-3'), document.getElementById('score-3')];

                if(step===0) {
                    if(!isTeam) {
                        // Tryb indywidualny - resetuj słupki (całkowicie ukryj)
                        b1.style.height='0%'; 
                        b2.style.height='0%'; 
                        b3.style.height='0%';
                        // Ukryj wszystkie elementy tekstowe
                        [...els1,...els2,...els3].forEach(e=>{
                            if(e) {
                                e.classList.remove('visible');
                                e.style.opacity = '0';
                                e.style.visibility = 'hidden';
                            }
                        });
                        // UKRYJ kolumny przy step=0 (żeby słupki nie były widoczne jako małe kratki)
                        const col1 = document.getElementById('pod-column-1');
                        const col2 = document.getElementById('pod-column-2');
                        const col3 = document.getElementById('pod-column-3');
                        if(col1) {
                            col1.style.display = 'none';
                            col1.style.visibility = 'hidden';
                            col1.style.opacity = '0';
                        }
                        if(col2) {
                            col2.style.display = 'none';
                            col2.style.visibility = 'hidden';
                            col2.style.opacity = '0';
                        }
                        if(col3) {
                            col3.style.display = 'none';
                            col3.style.visibility = 'hidden';
                            col3.style.opacity = '0';
                        }
                        // POKAŻ nagłówek PODIUM przy step=0 (tylko napis)
                        const podiumTitle = document.getElementById('podium-title-header');
                        if(podiumTitle) {
                            podiumTitle.style.setProperty('display', 'block', 'important');
                            podiumTitle.style.setProperty('visibility', 'visible', 'important');
                            podiumTitle.style.setProperty('opacity', '1', 'important');
                            podiumTitle.style.setProperty('text-align', 'center', 'important');
                            podiumTitle.style.setProperty('font-size', '6vw', 'important');
                            podiumTitle.style.setProperty('font-weight', '900', 'important');
                            podiumTitle.style.setProperty('margin-bottom', '20px', 'important');
                            podiumTitle.style.setProperty('background', '-webkit-linear-gradient(#f1c40f, #e67e22)', 'important');
                            podiumTitle.style.setProperty('-webkit-background-clip', 'text', 'important');
                            podiumTitle.style.setProperty('-webkit-text-fill-color', 'transparent', 'important');
                        }
                        // Ukryj karty drużynowe
                        const card1 = document.getElementById('podium-team-card-1');
                        const card2 = document.getElementById('podium-team-card-2');
                        if(card1) card1.style.display = 'none';
                        if(card2) card2.style.display = 'none';
                    } else {
                        // Tryb drużynowy - resetuj karty
                        const card1 = document.getElementById('podium-team-card-1');
                        const card2 = document.getElementById('podium-team-card-2');
                        if(card1) {
                            card1.classList.remove('revealed');
                            card1.style.display = 'none';
                            card1.style.opacity = '0';
                        }
                        if(card2) {
                            card2.classList.remove('revealed');
                            card2.style.display = 'none';
                            card2.style.opacity = '0';
                        }
                    }
                    currentPodiumStep=0;
                } else {
                    // Jeśli step > 0, upewnij się że podium jest widoczne
                    if(pod) pod.style.display='flex';
                }

                // TRYB INDYWIDUALNY - logika step (jak w starym pliku)
                if(!isTeam && step > 0) {
                    // Pokaż słupki, ukryj karty
                    const col1 = document.getElementById('pod-column-1');
                    const col2 = document.getElementById('pod-column-2');
                    const col3 = document.getElementById('pod-column-3');
                    const card1 = document.getElementById('podium-team-card-1');
                    const card2 = document.getElementById('podium-team-card-2');
                    const podiumContentContainer = document.getElementById('podium-content-container');
                    
                    // USTAW kontener dla słupków (flex-end żeby były na dole)
                    if(podiumContentContainer) {
                        podiumContentContainer.style.setProperty('display', 'flex', 'important');
                        podiumContentContainer.style.setProperty('flex-direction', 'row', 'important');
                        podiumContentContainer.style.setProperty('align-items', 'flex-end', 'important');
                        podiumContentContainer.style.setProperty('justify-content', 'center', 'important');
                        podiumContentContainer.style.setProperty('width', '100%', 'important');
                        podiumContentContainer.style.setProperty('visibility', 'visible', 'important');
                        podiumContentContainer.style.setProperty('opacity', '1', 'important');
                        podiumContentContainer.style.setProperty('height', '75%', 'important');
                        podiumContentContainer.style.setProperty('padding-bottom', '10vh', 'important');
                    }
                    
                    // POKAŻ kolumny gdy step > 0
                    if(col1) {
                        col1.style.display = '';
                        col1.style.visibility = 'visible';
                        col1.style.opacity = '1';
                    }
                    if(col2) {
                        col2.style.display = '';
                        col2.style.visibility = 'visible';
                        col2.style.opacity = '1';
                    }
                    if(col3) {
                        col3.style.display = '';
                        col3.style.visibility = 'visible';
                        col3.style.opacity = '1';
                    }
                    // UKRYJ karty drużynowe
                    if(card1) {
                        card1.style.display = 'none';
                        card1.style.visibility = 'hidden';
                        card1.style.opacity = '0';
                    }
                    if(card2) {
                        card2.style.display = 'none';
                        card2.style.visibility = 'hidden';
                        card2.style.opacity = '0';
                    }
                    
                    b1.style.display = '';
                    b2.style.display = '';
                    b3.style.display = '';
                    
                    // Pokaż nagłówek PODIUM dla trybu indywidualnego
                    const podiumTitle = document.getElementById('podium-title-header');
                    if(podiumTitle) {
                        podiumTitle.style.setProperty('display', 'block', 'important');
                        podiumTitle.style.setProperty('visibility', 'visible', 'important');
                        podiumTitle.style.setProperty('opacity', '1', 'important');
                    }
                    
                    // Logika step dla trybu indywidualnego (jak w starym pliku)
                    if(step===3) {
                        // Miejsce 3 - pokaż tylko miejsce 3
                        b3.style.height='35%'; 
                        b2.style.height='0%';
                        b1.style.height='0%';
                        // POKAŻ miejsce 3 (nick i wynik)
                        els3.forEach(e=>{
                            if(e) {
                                e.classList.add('visible');
                                e.style.opacity = '1';
                                e.style.visibility = 'visible';
                                e.style.display = '';
                            }
                        });
                        // UKRYJ miejsca 2 i 1
                        els2.forEach(e=>{
                            if(e) {
                                e.classList.remove('visible');
                                e.style.opacity = '0';
                                e.style.visibility = 'hidden';
                            }
                        });
                        els1.forEach(e=>{
                            if(e) {
                                e.classList.remove('visible');
                                e.style.opacity = '0';
                                e.style.visibility = 'hidden';
                            }
                        });
                        if(currentPodiumStep!==3){if(state.type!=='PODIUM')stopAllAudio();playSFX('win_3');showConfetti(3);}
                        currentPodiumStep=3;
                        console.log('🏆 Step 3 - miejsce 3 pokazane:', {
                            bar3Height: b3.style.height,
                            els3Visible: els3.map(e=>e ? e.classList.contains('visible') : false),
                            els3Opacity: els3.map(e=>e ? e.style.opacity : 'brak')
                        });
                    }
                    if(step===2) {
                        // Miejsce 2 - pokaż miejsca 3 i 2
                        b2.style.height='50%'; 
                        b3.style.height='35%';
                        b1.style.height='0%';
                        // POKAŻ miejsca 3 i 2 (nicki i wyniki)
                        els2.forEach(e=>{
                            if(e) {
                                e.classList.add('visible');
                                e.style.opacity = '1';
                                e.style.visibility = 'visible';
                                e.style.display = '';
                            }
                        }); 
                        els3.forEach(e=>{
                            if(e) {
                                e.classList.add('visible');
                                e.style.opacity = '1';
                                e.style.visibility = 'visible';
                                e.style.display = '';
                            }
                        });
                        // UKRYJ miejsce 1
                        els1.forEach(e=>{
                            if(e) {
                                e.classList.remove('visible');
                                e.style.opacity = '0';
                                e.style.visibility = 'hidden';
                            }
                        });
                        if(currentPodiumStep!==2){if(state.type!=='PODIUM')stopAllAudio();playSFX('win_2');showConfetti(2);}
                        currentPodiumStep=2;
                        console.log('🏆 Step 2 - miejsca 3 i 2 pokazane');
                    }
                    if(step===1) {
                        // Miejsce 1 - pokaż wszystkie miejsca (3, 2, 1)
                        b1.style.height='65%'; 
                        b2.style.height='50%'; 
                        b3.style.height='35%';
                        // POKAŻ wszystkie miejsca (nicki i wyniki)
                        [...els1,...els2,...els3].forEach(e=>{
                            if(e) {
                                e.classList.add('visible');
                                e.style.opacity = '1';
                                e.style.visibility = 'visible';
                                e.style.display = '';
                            }
                        });
                        if(currentPodiumStep!==1){if(state.type!=='PODIUM')stopAllAudio();playSFX('win_1');showConfetti(1);}
                        currentPodiumStep=1;
                        console.log('🏆 Step 1 - wszystkie miejsca pokazane');
                    }
                }

                if(isTeam) {
                    // Tryb drużynowy - użyj kart zamiast słupków
                    // Pokaż nagłówek PODIUM
                    const podiumTitle = document.getElementById('podium-title-header');
                    if(podiumTitle) {
                        podiumTitle.style.setProperty('display', 'block', 'important');
                        podiumTitle.style.setProperty('visibility', 'visible', 'important');
                        podiumTitle.style.setProperty('opacity', '1', 'important');
                        podiumTitle.style.setProperty('text-align', 'center', 'important');
                        podiumTitle.style.setProperty('font-size', '6vw', 'important');
                        podiumTitle.style.setProperty('font-weight', '900', 'important');
                        podiumTitle.style.setProperty('margin-bottom', '20px', 'important');
                        podiumTitle.style.setProperty('background', '-webkit-linear-gradient(#f1c40f, #e67e22)', 'important');
                        podiumTitle.style.setProperty('-webkit-background-clip', 'text', 'important');
                        podiumTitle.style.setProperty('-webkit-text-fill-color', 'transparent', 'important');
                        console.log('✅ Nagłówek PODIUM ustawiony na widoczny');
                    }
                    
                    // Upewnij się że kontener dla kart jest widoczny
                    const podiumContentContainer = document.getElementById('podium-content-container');
                    if(podiumContentContainer) {
                        podiumContentContainer.style.setProperty('display', 'flex', 'important');
                        podiumContentContainer.style.setProperty('flex-direction', 'row', 'important');
                        podiumContentContainer.style.setProperty('align-items', 'center', 'important');
                        podiumContentContainer.style.setProperty('justify-content', 'center', 'important');
                        podiumContentContainer.style.setProperty('width', '100%', 'important');
                        podiumContentContainer.style.setProperty('visibility', 'visible', 'important');
                        podiumContentContainer.style.setProperty('opacity', '1', 'important');
                        console.log('✅ Kontener podium-content-container ustawiony na widoczny');
                    }
                    
                    // Ukryj słupki i kolumny
                    const col1 = document.getElementById('pod-column-1');
                    const col2 = document.getElementById('pod-column-2');
                    const col3 = document.getElementById('pod-column-3');
                    if(col1) col1.style.display = 'none';
                    if(col2) col2.style.display = 'none';
                    if(col3) col3.style.display = 'none';
                    
                    // Pokaż karty - WAŻNE: ustaw display przed ustawianiem danych
                    const card1 = document.getElementById('podium-team-card-1');
                    const card2 = document.getElementById('podium-team-card-2');
                    
                    // Step 0 = reset - ukryj karty
                    if(step === 0) {
                        if(card1) {
                            card1.style.setProperty('display', 'none', 'important');
                            card1.classList.remove('revealed');
                        }
                        if(card2) {
                            card2.style.setProperty('display', 'none', 'important');
                            card2.classList.remove('revealed');
                        }
                        console.log('🔄 Step 0 - ukryto karty');
                    }
                    // Dla step > 0 karty będą pokazane przez konkretne kroki (step 2 i step 1)
                    
                    // Ustaw dane w kartach (używamy nowych ID z sufiksem -team)
                    if(card1) {
                        const nick1El = document.getElementById('nick-1-team');
                        const score1El = document.getElementById('score-1-team');
                        if(nick1El) nick1El.textContent = getName(w[0]) || '---';
                        if(score1El) score1El.textContent = (w[0]?.score || 0) + ' pkt';
                    }
                    if(card2) {
                        const nick2El = document.getElementById('nick-2-team');
                        const score2El = document.getElementById('score-2-team');
                        if(nick2El) nick2El.textContent = getName(w[1]) || '---';
                        if(score2El) score2El.textContent = (w[1]?.score || 0) + ' pkt';
                    }
                    
                    console.log('🏆 Tryb drużynowy - karty:', {
                        card1: card1 ? {
                            display: card1.style.display,
                            computedDisplay: window.getComputedStyle(card1).display,
                            hasRevealed: card1.classList.contains('revealed'),
                            opacity: card1.style.opacity,
                            computedOpacity: window.getComputedStyle(card1).opacity
                        } : null,
                        card2: card2 ? {
                            display: card2.style.display,
                            computedDisplay: window.getComputedStyle(card2).display,
                            hasRevealed: card2.classList.contains('revealed'),
                            opacity: card2.style.opacity,
                            computedOpacity: window.getComputedStyle(card2).opacity
                        } : null,
                        step: step,
                        winners: w
                    });
                    
                    // Dla kompatybilności z panelem admina: krok 3 traktujemy jak pokazanie 2 miejsca (TYLKO W TRYBIE DRUŻYNOWYM)
                    // WAŻNE: W trybie drużynowym step=3 jest traktowany jak step=2 (tylko 2 miejsca)
                    if(step === 3 || step === 2) {
                        // Miejsce 2 - odsłoń kartę z lewej
                        if(card2) {
                            // Upewnij się że kontener rodzic jest widoczny
                            const parentContainer = document.getElementById('podium-content-container');
                            if(parentContainer) {
                                parentContainer.style.setProperty('display', 'flex', 'important');
                                parentContainer.style.setProperty('flex-direction', 'row', 'important');
                                parentContainer.style.setProperty('align-items', 'center', 'important');
                                parentContainer.style.setProperty('justify-content', 'center', 'important');
                                parentContainer.style.setProperty('width', '100%', 'important');
                                parentContainer.style.setProperty('visibility', 'visible', 'important');
                                parentContainer.style.setProperty('opacity', '1', 'important');
                            }
                            
                            // Upewnij się że karta jest widoczna - USTAW WSZYSTKIE WŁAŚCIWOŚCI
                            card2.style.setProperty('display', 'flex', 'important');
                            card2.style.setProperty('visibility', 'visible', 'important');
                            card2.style.setProperty('opacity', '1', 'important');
                            card2.style.setProperty('transform', 'scale(1) translateY(0)', 'important');
                            card2.style.setProperty('min-width', '400px', 'important');
                            card2.style.setProperty('max-width', '500px', 'important');
                            card2.style.setProperty('margin', '0 40px', 'important');
                            if(!card2.classList.contains('revealed')) {
                                card2.classList.add('revealed');
                                if(currentPodiumStep !== 2 && currentPodiumStep !== 3) {
                                    if(state.type!=='PODIUM')stopAllAudio();
                                    playSFX('win_2');
                                    showConfetti(2);
                                }
                            }
                            console.log('✅ Karta 2 ustawiona:', {
                                display: card2.style.display,
                                opacity: card2.style.opacity,
                                transform: card2.style.transform,
                                hasRevealed: card2.classList.contains('revealed'),
                                offsetWidth: card2.offsetWidth,
                                offsetHeight: card2.offsetHeight,
                                parentDisplay: parentContainer ? window.getComputedStyle(parentContainer).display : 'brak'
                            });
                        }
                        currentPodiumStep = 2;
                    }
                    if(step === 1) {
                        // Miejsce 1 - odsłoń kartę z prawej
                        if(card1) {
                            // Upewnij się że kontener rodzic jest widoczny
                            const parentContainer = document.getElementById('podium-content-container');
                            if(parentContainer) {
                                parentContainer.style.setProperty('display', 'flex', 'important');
                                parentContainer.style.setProperty('flex-direction', 'row', 'important');
                                parentContainer.style.setProperty('align-items', 'center', 'important');
                                parentContainer.style.setProperty('justify-content', 'center', 'important');
                                parentContainer.style.setProperty('width', '100%', 'important');
                                parentContainer.style.setProperty('visibility', 'visible', 'important');
                                parentContainer.style.setProperty('opacity', '1', 'important');
                            }
                            
                            // Upewnij się że karta jest widoczna - USTAW WSZYSTKIE WŁAŚCIWOŚCI
                            card1.style.setProperty('display', 'flex', 'important');
                            card1.style.setProperty('visibility', 'visible', 'important');
                            card1.style.setProperty('opacity', '1', 'important');
                            card1.style.setProperty('transform', 'scale(1) translateY(0)', 'important');
                            card1.style.setProperty('min-width', '400px', 'important');
                            card1.style.setProperty('max-width', '500px', 'important');
                            card1.style.setProperty('margin', '0 40px', 'important');
                            if(!card1.classList.contains('revealed')) {
                                card1.classList.add('revealed');
                                // Upewnij się że miejsce 2 też jest widoczne
                                if(card2) {
                                    card2.style.setProperty('display', 'flex', 'important');
                                    card2.style.setProperty('visibility', 'visible', 'important');
                                    card2.style.setProperty('opacity', '1', 'important');
                                    card2.style.setProperty('transform', 'scale(1) translateY(0)', 'important');
                                    card2.style.setProperty('min-width', '400px', 'important');
                                    card2.style.setProperty('max-width', '500px', 'important');
                                    card2.style.setProperty('margin', '0 40px', 'important');
                                    if(!card2.classList.contains('revealed')) {
                                        card2.classList.add('revealed');
                                    }
                                }
                                if(currentPodiumStep !== 1) {
                                    if(state.type!=='PODIUM')stopAllAudio();
                                    playSFX('win_1');
                                    showConfetti(1);
                                }
                            }
                            console.log('✅ Karta 1 ustawiona:', {
                                display: card1.style.display,
                                opacity: card1.style.opacity,
                                transform: card1.style.transform,
                                hasRevealed: card1.classList.contains('revealed'),
                                offsetWidth: card1.offsetWidth,
                                offsetHeight: card1.offsetHeight,
                                parentDisplay: parentContainer ? window.getComputedStyle(parentContainer).display : 'brak'
                            });
                        }
                        currentPodiumStep = 1;
                    }
                    
                    // Debug - sprawdź finalny stan kart i WYMUŚ widoczność jeśli potrzeba
                    setTimeout(() => {
                        const card1Computed = card1 ? window.getComputedStyle(card1) : null;
                        const card2Computed = card2 ? window.getComputedStyle(card2) : null;
                        
                        // Szczegółowe logi dla każdej karty osobno
                        if(card1) {
                            console.log('🏆 Karta 1 - szczegóły:', {
                                step: step,
                                display: card1.style.display,
                                computedDisplay: card1Computed?.display,
                                visibility: card1Computed?.visibility,
                                opacity: card1Computed?.opacity,
                                transform: card1Computed?.transform,
                                hasRevealed: card1.classList.contains('revealed'),
                                offsetWidth: card1.offsetWidth,
                                offsetHeight: card1.offsetHeight,
                                clientWidth: card1.clientWidth,
                                clientHeight: card1.clientHeight,
                                nick1Text: document.getElementById('nick-1-team')?.textContent || 'brak',
                                score1Text: document.getElementById('score-1-team')?.textContent || 'brak',
                                parentDisplay: card1.parentElement ? window.getComputedStyle(card1.parentElement).display : 'brak'
                            });
                        }
                        if(card2) {
                            console.log('🏆 Karta 2 - szczegóły:', {
                                step: step,
                                display: card2.style.display,
                                computedDisplay: card2Computed?.display,
                                visibility: card2Computed?.visibility,
                                opacity: card2Computed?.opacity,
                                transform: card2Computed?.transform,
                                hasRevealed: card2.classList.contains('revealed'),
                                offsetWidth: card2.offsetWidth,
                                offsetHeight: card2.offsetHeight,
                                clientWidth: card2.clientWidth,
                                clientHeight: card2.clientHeight,
                                nick2Text: document.getElementById('nick-2-team')?.textContent || 'brak',
                                score2Text: document.getElementById('score-2-team')?.textContent || 'brak',
                                parentDisplay: card2.parentElement ? window.getComputedStyle(card2.parentElement).display : 'brak'
                            });
                        }
                        
                        // WYMUŚ widoczność jeśli karty mają klasę revealed ale są niewidoczne
                        if(card1 && card1.classList.contains('revealed')) {
                            if(card1Computed && (card1Computed.display === 'none' || card1Computed.opacity === '0' || card1.offsetWidth === 0)) {
                                console.warn('⚠️ Karta 1 ma revealed ale jest niewidoczna - wymuszam', {
                                    display: card1Computed.display,
                                    opacity: card1Computed.opacity,
                                    offsetWidth: card1.offsetWidth,
                                    offsetHeight: card1.offsetHeight,
                                    parentDisplay: card1.parentElement ? window.getComputedStyle(card1.parentElement).display : 'brak',
                                    parentId: card1.parentElement ? card1.parentElement.id : 'brak'
                                });
                                
                                // Upewnij się że rodzic jest widoczny
                                const parent = card1.parentElement;
                                if(parent) {
                                    parent.style.setProperty('display', 'flex', 'important');
                                    parent.style.setProperty('visibility', 'visible', 'important');
                                    parent.style.setProperty('opacity', '1', 'important');
                                }
                                
                                card1.style.setProperty('display', 'flex', 'important');
                                card1.style.setProperty('visibility', 'visible', 'important');
                                card1.style.setProperty('opacity', '1', 'important');
                                card1.style.setProperty('transform', 'scale(1) translateY(0)', 'important');
                                card1.style.setProperty('min-width', '400px', 'important');
                                card1.style.setProperty('max-width', '500px', 'important');
                            }
                        }
                        if(card2 && card2.classList.contains('revealed')) {
                            if(card2Computed && (card2Computed.display === 'none' || card2Computed.opacity === '0' || card2.offsetWidth === 0)) {
                                console.warn('⚠️ Karta 2 ma revealed ale jest niewidoczna - wymuszam', {
                                    display: card2Computed.display,
                                    opacity: card2Computed.opacity,
                                    offsetWidth: card2.offsetWidth,
                                    offsetHeight: card2.offsetHeight,
                                    parentDisplay: card2.parentElement ? window.getComputedStyle(card2.parentElement).display : 'brak',
                                    parentId: card2.parentElement ? card2.parentElement.id : 'brak'
                                });
                                
                                // Upewnij się że rodzic jest widoczny
                                const parent = card2.parentElement;
                                if(parent) {
                                    parent.style.setProperty('display', 'flex', 'important');
                                    parent.style.setProperty('visibility', 'visible', 'important');
                                    parent.style.setProperty('opacity', '1', 'important');
                                }
                                
                                card2.style.setProperty('display', 'flex', 'important');
                                card2.style.setProperty('visibility', 'visible', 'important');
                                card2.style.setProperty('opacity', '1', 'important');
                                card2.style.setProperty('transform', 'scale(1) translateY(0)', 'important');
                                card2.style.setProperty('min-width', '400px', 'important');
                                card2.style.setProperty('max-width', '500px', 'important');
                            }
                        }
                    }, 200);
                }

                // Debug - sprawdź czy słupki mają wysokości
                console.log('PODIUM bars:', {
                    bar1: b1.style.height,
                    bar2: b2.style.height,
                    bar3: b3.style.height,
                    step: step
                });

                return;
            } else {
                currentPodiumStep = -1;
            }
            // GAME LOGIC
            const q = state.activeQuestion;
            const qEl = document.getElementById('main-q');
            let inPlayoff = !!(state.playoff && state.playoff.active);
            const rawText = inPlayoff ? (state.playoff.word || '') : (q?.question || '');

            // ⚠️ WAŻNE: Wyczyść obrazek hero na początku każdego pytania, aby uniknąć "ghost image"
            const heroContainer = document.getElementById('hero-image-container');
            const heroImg = document.getElementById('hero-image');
            if(heroContainer && heroImg) {
                heroContainer.style.display = 'none';
                // Ustaw pusty src lub data URL zamiast pustego stringa, aby uniknąć błędów
                heroImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                heroImg.onerror = null;
                heroImg.onload = null;
                console.log('🧹 Wyczyszczono hero obrazek na początku pytania');
            }

            // Reset klas wieloliniowych
            qEl.classList.remove('multi-line', 'two-lines', 'three-lines');

            // W trakcie dogrywki: w miejscu pytania prezentuj słowo wybrane do dogrywki
            if(inPlayoff && state.playoff && state.playoff.word) {
                const playoffWord = state.playoff.word || '';
                qEl.innerHTML = `
                    <div class="playoff-word-screen" style="font-size: clamp(1.8rem, 5vw, 4rem); font-weight: 900; color: white; text-align: center; margin-bottom: 12px; text-transform: uppercase; text-shadow: 0 2px 12px rgba(0,0,0,0.5);">${playoffWord}</div>
                    <div class="playoff-title-pulse-screen" style="font-size: clamp(1.2rem, 4vw, 2.5rem); font-weight: 900; background: -webkit-linear-gradient(#f1c40f, #e67e22); background-clip: text; -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-transform: uppercase; letter-spacing: clamp(2px, 1vw, 5px); text-align: center; animation: titlePulse 3s ease-in-out infinite;">🎤 DOGRYWKA</div>
                `;
            } else {
                // Dzielenie tekstu pytania na 2-3 linie dla dłuższych pytań
                if(rawText.length > 0 && !rawText.includes('<br>')) {
                const textLength = rawText.length;
                let formattedText = rawText;
                
                // Dla bardzo długich pytań (>100 znaków) - 3 linie
                if(textLength > 100) {
                    const third1 = Math.floor(textLength / 3);
                    const third2 = Math.floor(textLength * 2 / 3);
                    
                    const space1 = rawText.lastIndexOf(' ', third1);
                    const space2 = rawText.lastIndexOf(' ', third2);
                    const space3 = rawText.indexOf(' ', third2);
                    
                    let split1 = space1 > 0 ? space1 : third1;
                    let split2 = space2 > split1 ? space2 : (space3 > split1 ? space3 : third2);
                    
                    if(split1 > 0 && split2 > split1) {
                        formattedText = rawText.substring(0, split1) + '<br>' + 
                                       rawText.substring(split1 + 1, split2) + '<br>' + 
                                       rawText.substring(split2 + 1);
                        qEl.classList.add('multi-line', 'three-lines');
                    } else if(split1 > 0) {
                        formattedText = rawText.substring(0, split1) + '<br>' + rawText.substring(split1 + 1);
                        qEl.classList.add('multi-line', 'two-lines');
                    }
                }
                // Dla średnich pytań (60-100 znaków) - 2 linie
                else if(textLength > 60) {
                    const mid = Math.floor(textLength / 2);
                    const leftSpace = rawText.lastIndexOf(' ', mid);
                    const rightSpace = rawText.indexOf(' ', mid);
                    let splitIdx = -1;
                    
                    if(leftSpace === -1) splitIdx = rightSpace;
                    else if(rightSpace === -1) splitIdx = leftSpace;
                    else splitIdx = (mid - leftSpace < rightSpace - mid) ? leftSpace : rightSpace;

                    if(splitIdx !== -1 && splitIdx > 0) {
                        formattedText = rawText.substring(0, splitIdx) + '<br>' + rawText.substring(splitIdx + 1);
                        qEl.classList.add('multi-line', 'two-lines');
                    }
                }
                
                    qEl.innerHTML = formattedText;
                } else if(rawText.includes('<br>')) {
                    // Jeśli już ma <br>, zachowaj ale dodaj klasę
                    qEl.innerHTML = rawText;
                    const lineCount = (rawText.match(/<br>/g) || []).length + 1;
                    if(lineCount >= 3) {
                        qEl.classList.add('multi-line', 'three-lines');
                    } else if(lineCount === 2) {
                        qEl.classList.add('multi-line', 'two-lines');
                    }
                } else {
                    qEl.innerText = rawText;
                }
            }

            // BATTLE BAR
            const battleBar = document.getElementById('live-battle-bar-container');
            if(inPlayoff) {
                battleBar.style.display='none';
            } else if(q?.type==='VOTE' || q?.type==='VOTE_IMG' || q?.type==='HOT_OR_NOT') {
                currentMode='VOTE';
                battleBar.style.display='block';
                updateLiveBar(state.stats);
            } else if(q?.type==='ESTIMATION') {
                currentMode='ESTIMATION';
                battleBar.style.display='none';
            } else if(q?.type==='OPEN') {
                currentMode='OPEN';
                battleBar.style.display='none';
            } else if(q?.type==='SHIPS') {
                currentMode='SHIPS';
                battleBar.style.display='none';
                // WAŻNE: Zmniejsz cień header dla pytań typu SHIPS aby nie zasłaniał planszy
                const headerEl = document.querySelector('.header');
                if (headerEl) {
                    headerEl.style.boxShadow = '0 2px 10px rgba(0,0,0,0.2)'; // Zmniejszony cień
                }
                // WAŻNE: Zawsze renderuj planszę gdy przychodzi update_state dla SHIPS
                // To zapewnia że plansza jest aktualizowana po kliknięciu "Następna runda"
                renderShipsBoard(q, state);
                // WAŻNE: Dla SHIPS nie kontynuuj dalej - renderShipsBoard już ustawił grid.innerHTML
                // Dodaj klasy dla showStats/showCorrect ale nie czyść gridu
                const grid = document.getElementById('quiz-grid');
                // Upewnij się że style są ustawione (renderShipsBoard już to robi, ale na wszelki wypadek)
                grid.style.cssText = 'display: block !important; width: 100% !important; flex: 1 !important; min-height: 0 !important; overflow: auto !important;';
                grid.classList.remove('show-correct', 'show-stats');
                if(state.showCorrect) {
                    grid.classList.add('show-correct');
                    clockPlayer.pause();
                    if(!grid.dataset.playedC){ stopAllAudio(); playSFX('correct_answer'); grid.dataset.playedC='true'; }
                } else {
                    grid.dataset.playedC='';
                }
                if(state.showStats && !state.showCorrect) {
                    grid.classList.add('show-stats');
                    clockPlayer.pause();
                    if(!grid.dataset.playedS){ stopAllAudio(); playSFX('stats_show'); grid.dataset.playedS='true'; }
                } else if(!state.showStats) {
                    grid.dataset.playedS='';
                }
                return; // WAŻNE: Wyjdź wcześnie - nie czyść gridu dla SHIPS
            } else {
                currentMode='QUIZ';
                battleBar.style.display='none';
                // WAŻNE: Przywróć normalny cień header dla innych typów pytań
                const headerEl = document.querySelector('.header');
                if (headerEl) {
                    headerEl.style.boxShadow = ''; // Przywróć domyślny cień z CSS
                }
            }

            // SHOW CORRECT / SHOW STATS
            const grid = document.getElementById('quiz-grid');
            
            // Reset klas przed ponownym nałożeniem
            grid.classList.remove('show-correct', 'show-stats');
            
            if(state.showCorrect) {
                grid.classList.add('show-correct');
                clockPlayer.pause();
                if(!grid.dataset.playedC){ stopAllAudio(); playSFX('correct_answer'); grid.dataset.playedC='true'; }
            } else {
                grid.dataset.playedC='';
            }

            if(state.showStats && !state.showCorrect) {
                grid.classList.add('show-stats');
                clockPlayer.pause();
                if(!grid.dataset.playedS){ stopAllAudio(); playSFX('stats_show'); grid.dataset.playedS='true'; }
            } else if(!state.showStats) {
                grid.dataset.playedS='';
            }

            // NOWE PYTANIE - DETEKCJA
            if(state.activeQuestionIndex !== window.lastQIndex) {
                window.lastQIndex = state.activeQuestionIndex;
                
                // Sprawdź czy to naprawdę nowe pytanie (nie tylko zmiana stanu z GAME_STATS z powrotem do GAME)
                const currentQuestionId = q?.id !== undefined && q?.id !== null ? q.id : `q_${state.activeQuestionIndex || 0}`;
                const isNewQuestion = currentQuestionId !== lastQuestionId;
                // Sprawdź czy poprzedni stan był GAME_STATS lub GAME ze statystykami/poprawną odpowiedzią
                const wasStatsOrCorrect = previousStateType === 'GAME_STATS' || 
                                         (previousStateType === 'GAME' && (state.showStats || state.showCorrect));
                
                // WAŻNE: Dla pytań muzycznych NIE wywołuj stopAllAudio() przed odtworzeniem
                // Zatrzymaj tylko jeśli to NIE jest pytanie muzyczne
                // Nie wymagaj !wasStatsOrCorrect – przy przejściu z GAME_STATS (wyniki poprzedniego) do nowego pytania muzycznego też odtwarzamy
                if(q && q.type === 'MUSIC' && q.audio && isNewQuestion && state.type === 'GAME') {
                    console.log('🎵 Screen.html - Odtwarzam dźwięk dla nowego pytania muzycznego (w sekcji NOWE PYTANIE):', {
                        audio: q.audio,
                        questionId: currentQuestionId,
                        lastQuestionId: lastQuestionId,
                        isNewQuestion: isNewQuestion,
                        stateType: state.type,
                        note: 'stopAllAudio() będzie wywołane w playMusic()'
                    });
                    // playMusic() wywołuje stopAllAudio() wewnątrz, więc nie trzeba go wywoływać tutaj
                    playMusic(q.audio);
                    // WAŻNE: Zaktualizuj lastQuestionId TUTAJ, po odtworzeniu dźwięku, aby uniknąć wielokrotnego odtwarzania
                    lastQuestionId = currentQuestionId;
                } else {
                    // Dla innych pytań zatrzymaj wszystkie dźwięki
                    stopAllAudio();
                }
                
                // Odtwarzaj dźwięk tylko gdy pokazuje się naprawdę nowe pytanie, nie gdy gracz klika odpowiedź
                // WAŻNE: Nie odtwarzaj dźwięku jeśli:
                // - pokazujemy statystyki lub poprawną odpowiedź
                // - to nie jest nowe pytanie (tylko zmiana stanu)
                // - poprzedni stan był GAME_STATS lub GAME ze statystykami
                // - pytanie ma audio (muzyczne) - już obsłużone wyżej
                if(isNewQuestion && !q?.audio && !state.showStats && !state.showCorrect && state.type === 'GAME' && !wasStatsOrCorrect) {
                    console.log('🔊 Odtwarzam dźwięk question_open dla nowego pytania:', currentQuestionId);
                    playSFX('question_open');
                } else {
                    console.log('🔇 Pomijam dźwięk question_open:', {
                        isNewQuestion,
                        hasAudio: !!q?.audio,
                        showStats: state.showStats,
                        showCorrect: state.showCorrect,
                        type: state.type,
                        wasStatsOrCorrect,
                        previousStateType,
                        currentQuestionId,
                        lastQuestionId
                    });
                }
                
                // WAŻNE: Zaktualizuj lastQuestionId TYLKO jeśli nie było pytania muzycznego (dla muzycznego jest już zaktualizowane wyżej)
                if(!(q && q.type === 'MUSIC' && q.audio && isNewQuestion && state.type === 'GAME')) {
                    lastQuestionId = currentQuestionId;
                }

                // RESET ANIMACJI - tylko jeśli nie pokazujemy statystyk ani poprawnej odpowiedzi
                if(!state.showStats && !state.showCorrect) {
                    qEl.classList.remove('animate-question');
                    void qEl.offsetWidth; 
                    qEl.classList.add('animate-question');

                    document.body.classList.remove('new-question-pulse');
                    void document.body.offsetWidth;
                    document.body.classList.add('new-question-pulse');

                    grid.classList.add('run-animation');
                    setTimeout(()=>{
                        grid.classList.remove('run-animation');
                    },3000);
                }

                if(currentMode==='VOTE') {
                    document.getElementById('live-battle-bar-fill').style.width='50%';
                    document.getElementById('score-val-a').innerText='0%';
                    document.getElementById('score-val-b').innerText='0%';
                }
            }

            // OBRAZEK HERO - wyświetlaj dla QUIZ i VOTE (nie dla MUSIC i HOT_OR_NOT)
            // UWAGA: heroContainer i heroImg są już zdefiniowane na początku sekcji GAME
            
            console.log('🖼️ Sprawdzam obrazek:', {
                'type': q?.type,
                'image': q?.image,
                'media': q?.media,
                'image exists': !!q?.image,
                'image length': q?.image ? q.image.length : 0,
                'media exists': !!q?.media,
                'media length': q?.media ? q.media.length : 0
            });
            
            // Dogrywka – bez obrazka
            if(inPlayoff) {
                heroContainer.style.display = 'none';
                heroImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            }
            // HOT_OR_NOT ma własny układ obrazków - ukryj hero (już wyczyszczone na początku)
            else if(q?.type === 'HOT_OR_NOT') {
                // Upewnij się że hero jest ukryty (już wyczyszczone na początku)
                heroContainer.style.display = 'none';
                // Ustaw pusty src lub data URL zamiast pustego stringa, aby uniknąć błędów
                heroImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                heroImg.onerror = null;
                heroImg.onload = null;
                // NIE używaj return - musimy renderować grid HOT_OR_NOT poniżej!
            }
            // Dla MUSIC nie pokazuj obrazka (tylko audio)
            else if(q?.type === 'MUSIC') {
                heroContainer.style.display = 'none';
                heroImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
            }
            // Szacowanie – opcjonalnie z obrazkiem (np. „oszacuj ile osób na zdjęciu”)
            else if(q?.type === 'ESTIMATION') {
                let imageToUseEst = (q?.image && q.image.trim() !== '') ? q.image : (q?.media && q.media.trim() !== '') ? q.media : '';
                if (imageToUseEst && imageToUseEst.trim() !== '') {
                    if (!imageToUseEst.startsWith('/') && !imageToUseEst.startsWith('http')) imageToUseEst = '/uploads/' + imageToUseEst;
                    heroContainer.style.display = 'block';
                    heroImg.src = imageToUseEst;
                    triggerHeroReveal();
                } else {
                    heroContainer.style.display = 'none';
                    heroImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                }
            }
            // Pytanie z literą – opcjonalnie z obrazkiem
            // Ukryj grafikę gdy pokazujemy statystyki (chmurę słów)
            else if(q?.type === 'LETTER') {
                if(state.showStats || state.showCorrect) {
                    // Ukryj grafikę gdy pokazujemy chmurę słów
                    heroContainer.style.display = 'none';
                    heroImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                } else {
                    let imageToUseLetter = (q?.image && q.image.trim() !== '') ? q.image : (q?.media && q.media.trim() !== '') ? q.media : '';
                    if (imageToUseLetter && imageToUseLetter.trim() !== '') {
                        if (!imageToUseLetter.startsWith('/') && !imageToUseLetter.startsWith('http')) imageToUseLetter = '/uploads/' + imageToUseLetter;
                        heroContainer.style.display = 'block';
                        heroImg.src = imageToUseLetter;
                        triggerHeroReveal();
                    } else {
                        heroContainer.style.display = 'none';
                        heroImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                    }
                }
            }
            // Dla innych typów z obrazkiem - pokaż (użyj image lub media jako fallback)
            else {
                // Użyj image, jeśli istnieje, w przeciwnym razie użyj media
                let imageToUse = '';
                if(q?.image && q.image.trim() !== '') {
                    imageToUse = q.image;
                } else if(q?.media && q.media.trim() !== '' && q?.type !== 'MUSIC') {
                    imageToUse = q.media;
                }
                
                console.log('🖼️ Screen.html - q.image:', q?.image, 'q.media:', q?.media, 'imageToUse:', imageToUse);
                
                if(imageToUse && imageToUse.trim() !== '') {
                
                // Obsługa różnych formatów ścieżek obrazków
                let imageSrc = imageToUse;
                if (!imageSrc.startsWith('/') && !imageSrc.startsWith('http')) {
                    imageSrc = '/uploads/' + imageSrc;
                }
                
                // Jeśli ścieżka zaczyna się od /uploads/, upewnij się że jest pełna
                if(imageSrc.startsWith('/uploads/') && !imageSrc.startsWith('http')) {
                    // To jest OK - użyj bezpośrednio
                }
                
                console.log('🖼️ Ścieżka obrazka:', imageSrc);
                console.log('🖼️ Aktualne src obrazka:', heroImg.src);
                
                // Ustaw źródło obrazka - zawsze ustaw poprawną ścieżkę
                // Pobierz aktualny src bez origin (tylko ścieżka)
                let currentSrc = '';
                try {
                    const fullSrc = heroImg.src;
                    if(fullSrc && fullSrc !== window.location.href && !fullSrc.includes('screen.html') && !fullSrc.includes('vote.html')) {
                        // Jeśli src zawiera pełny URL, wyciągnij tylko ścieżkę
                        if(fullSrc.startsWith('http')) {
                            const url = new URL(fullSrc);
                            currentSrc = url.pathname;
                        } else {
                            currentSrc = fullSrc;
                        }
                    }
                } catch(e) {
                    // Jeśli nie można sparsować URL, użyj pustego
                    currentSrc = '';
                }
                
                console.log('🖼️ Porównanie ścieżek - currentSrc:', currentSrc, 'imageSrc:', imageSrc, 'heroImg.src:', heroImg.src);
                
                // Zawsze ustaw poprawną ścieżkę obrazka - sprawdź czy src jest nieprawidłowe
                const srcIsInvalid = !currentSrc || 
                                    currentSrc.includes('screen.html') || 
                                    currentSrc.includes('vote.html') ||
                                    heroImg.src === window.location.href ||
                                    (heroImg.src && heroImg.src.includes(window.location.href) && !heroImg.src.includes('/uploads/'));
                
                // Zawsze ustaw poprawną ścieżkę (niezależnie od poprzedniej wartości)
                console.log('🖼️ Ustawiam src obrazka na:', imageSrc);
                // Wyczyść src i ustaw poprawną ścieżkę
                heroImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                // Użyj małego opóźnienia aby upewnić się że src jest czysty
                setTimeout(() => {
                    heroImg.src = imageSrc;
                    console.log('✅ Ustawiono heroImg.src na:', heroImg.src, 'powinno być:', imageSrc);
                    
                    // Sprawdź czy src jest poprawne po ustawieniu
                    setTimeout(() => {
                        if(heroImg.src !== imageSrc && !heroImg.src.includes('/uploads/') && !heroImg.src.includes('http')) {
                            console.error('⚠️ PROBLEM: heroImg.src nie jest poprawne po ustawieniu!', {
                                'oczekiwane': imageSrc,
                                'rzeczywiste': heroImg.src,
                                'currentSrc': heroImg.currentSrc
                            });
                            // Wymuś poprawkę
                            heroImg.src = imageSrc;
                        }
                    }, 50);
                }, 10);
                
                // Pokaż kontener OD RAZU (nie czekaj na załadowanie)
                heroContainer.style.display = 'flex';
                heroContainer.style.visibility = 'visible';
                heroContainer.style.opacity = '1';
                heroContainer.style.height = 'auto';
                heroContainer.style.width = '100%';
                triggerHeroReveal();
                
                // Ustaw odpowiednie wymiary w zależności od trybu
                if(currentMode === 'VOTE') {
                    heroContainer.style.minHeight = '360px';
                    heroContainer.style.maxHeight = '82vh';
                    heroContainer.style.flexGrow = '1';
                    heroContainer.classList.add('vote-mode');
                } else {
                    heroContainer.style.minHeight = '180px';
                    heroContainer.style.maxHeight = '78vh';
                    heroContainer.style.flexGrow = '1';
                    heroContainer.classList.remove('vote-mode');
                }
                
                heroContainer.style.flexShrink = '0';
                
                // Upewnij się że obrazek ma odpowiednie wymiary
                heroImg.style.maxWidth = '100%';
                heroImg.style.width = 'auto';
                heroImg.style.height = 'auto';
                heroImg.style.display = 'block';
                heroImg.style.visibility = 'visible';
                heroImg.style.opacity = '1';
                
                // Upewnij się że obrazek się załaduje
                heroImg.onerror = function() {
                    console.error('❌ Błąd ładowania obrazka:', {
                        'heroImg.src': heroImg.src,
                        'heroImg.currentSrc': heroImg.currentSrc || 'brak',
                        'q.image': q?.image,
                        'q.media': q?.media,
                        'imageSrc': imageSrc,
                        'imageToUse': imageToUse,
                        'window.location.href': window.location.href
                    });
                    
                    // Jeśli src jest nieprawidłowe (zawiera URL strony), popraw to
                    if(heroImg.src.includes('screen.html') || heroImg.src.includes('vote.html') || heroImg.src === window.location.href) {
                        console.log('⚠️ Wykryto nieprawidłowy src (URL strony), poprawiam na:', imageSrc);
                        heroImg.src = imageSrc;
                        return; // Nie ukrywaj kontenera jeszcze
                    }
                    
                    // Spróbuj przeładować obrazek
                    console.log('⚠️ Spróbuję przeładować obrazek...');
                    setTimeout(() => {
                        if(heroImg.src !== imageSrc && !heroImg.src.includes('screen.html') && !heroImg.src.includes('vote.html')) {
                            heroImg.src = imageSrc;
                        } else if(heroImg.src.includes('screen.html') || heroImg.src.includes('vote.html')) {
                            // Jeśli nadal jest nieprawidłowy, wymuś poprawkę
                            heroImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                            setTimeout(() => {
                                heroImg.src = imageSrc;
                            }, 50);
                        }
                    }, 100);
                };
                heroImg.onload = function() {
                    console.log('✅ Obrazek załadowany:', heroImg.src, 'wymiary:', heroImg.naturalWidth, 'x', heroImg.naturalHeight);
                    heroContainer.style.display='flex';
                    heroContainer.style.visibility = 'visible';
                    heroContainer.style.opacity = '1';
                    heroContainer.style.width = '100%';
                    
                    // Ustaw odpowiednie wymiary w zależności od trybu
                    if(currentMode === 'VOTE') {
                        heroContainer.style.minHeight = '360px';
                        heroContainer.style.maxHeight = '82vh';
                        heroContainer.style.flexGrow = '1';
                        heroContainer.classList.add('vote-mode');
                    } else {
                        heroContainer.style.minHeight = '180px';
                        heroContainer.style.maxHeight = '78vh';
                        heroContainer.style.flexGrow = '1';
                        heroContainer.classList.remove('vote-mode');
                    }
                    
                    heroContainer.style.flexShrink = '0';
                    
                    // Upewnij się że obrazek jest widoczny
                    heroImg.style.display = 'block';
                    heroImg.style.visibility = 'visible';
                    heroImg.style.opacity = '1';
                    heroImg.style.maxWidth = '100%';
                    heroImg.style.width = 'auto';
                    heroImg.style.height = 'auto';
                    
                    console.log('✅ Kontener po załadowaniu - display:', heroContainer.style.display, 'visibility:', heroContainer.style.visibility, 'width:', heroContainer.style.width);
                    console.log('✅ Obrazek po załadowaniu - display:', heroImg.style.display, 'naturalWidth:', heroImg.naturalWidth, 'naturalHeight:', heroImg.naturalHeight);
                };
                
                // Sprawdź czy obrazek jest już załadowany (complete property)
                if(heroImg.complete && heroImg.naturalHeight > 0) {
                    console.log('✅ Obrazek już załadowany (complete), wymiary:', heroImg.naturalWidth, 'x', heroImg.naturalHeight);
                    heroContainer.style.display='flex';
                    heroContainer.style.visibility = 'visible';
                    heroContainer.style.opacity = '1';
                    heroContainer.style.width = '100%';
                    
                    // Ustaw odpowiednie wymiary w zależności od trybu
                    if(currentMode === 'VOTE') {
                        heroContainer.style.minHeight = '360px';
                        heroContainer.style.maxHeight = '82vh';
                        heroContainer.style.flexGrow = '1';
                        heroContainer.classList.add('vote-mode');
                    } else {
                        heroContainer.style.minHeight = '180px';
                        heroContainer.style.maxHeight = '78vh';
                        heroContainer.style.flexGrow = '1';
                        heroContainer.classList.remove('vote-mode');
                    }
                    
                    heroContainer.style.flexShrink = '0';
                    
                    // Upewnij się że obrazek jest widoczny
                    heroImg.style.display = 'block';
                    heroImg.style.visibility = 'visible';
                    heroImg.style.opacity = '1';
                    heroImg.style.maxWidth = '100%';
                    heroImg.style.width = 'auto';
                    heroImg.style.height = 'auto';
                    
                    console.log('✅ Kontener dla już załadowanego - display:', heroContainer.style.display, 'width:', heroContainer.style.width);
                }
                
                // Debug - sprawdź rzeczywisty stan kontenera po chwili
                setTimeout(() => {
                    const computedStyle = window.getComputedStyle(heroContainer);
                    console.log('🔍 Debug kontenera po 100ms:');
                    console.log('  - display:', computedStyle.display);
                    console.log('  - visibility:', computedStyle.visibility);
                    console.log('  - opacity:', computedStyle.opacity);
                    console.log('  - height:', computedStyle.height);
                    console.log('  - max-height:', computedStyle.maxHeight);
                    console.log('  - width:', computedStyle.width);
                    console.log('  - z-index:', computedStyle.zIndex);
                    console.log('  - position:', computedStyle.position);
                    console.log('  - Obrazek src:', heroImg.src);
                    console.log('  - Obrazek naturalWidth:', heroImg.naturalWidth);
                    console.log('  - Obrazek naturalHeight:', heroImg.naturalHeight);
                    console.log('  - Obrazek offsetWidth:', heroImg.offsetWidth);
                    console.log('  - Obrazek offsetHeight:', heroImg.offsetHeight);
                }, 100);
                } else {
                    // Brak obrazka dla tego typu pytania - ukryj kontener i wyczyść src
                    console.log('🖼️ Ukrywam kontener obrazka - brak obrazka dla typu:', q?.type);
                    heroContainer.style.display='none';
                    // Ustaw pusty src lub data URL zamiast pustego stringa, aby uniknąć błędów
                    heroImg.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
                    heroImg.onerror = null;
                    heroImg.onload = null;
                }
            }

            // BUDOWA GRIDÓW
            grid.innerHTML = '';
            // Resetuj style inline gdy przechodzimy do innego typu pytania (nie SHIPS)
            if (q?.type !== 'SHIPS') {
                grid.style.cssText = '';
                grid.className = 'quiz-grid';
            }
            const answers = q?.answers || [];
            
            // Policz niepuste odpowiedzi (filtruj puste stringi)
            const nonEmptyAnswers = answers.filter(ans => ans && ans.trim() !== '');
            const answerCount = nonEmptyAnswers.length;
            
            // Sprawdź czy jest obrazek dla VOTE (użyj image lub media jako fallback)
            let hasImage = false;
            if(q?.type !== 'MUSIC' && q?.type !== 'HOT_OR_NOT') {
                hasImage = (q?.image && q.image.trim() !== '') || (q?.media && q.media.trim() !== '');
            }
            
            const contentArea = document.getElementById('content-area');
            
            // HOT_OR_NOT - specjalny układ z dwoma obrazkami
            if(q?.type === 'HOT_OR_NOT') {
                // Nie dodawaj run-animation jeśli pokazujemy statystyki lub poprawną odpowiedź (aby nie restartować animacji przy aktualizacji statystyk)
                const shouldAnimate = !state.showStats && !state.showCorrect && state.activeQuestionIndex !== window.lastQIndex;
                grid.className = 'quiz-grid grid-hot-or-not' + (shouldAnimate ? ' run-animation' : '');
                
                // Użyj imageA/imageB z pytania (nie z zmiennych zewnętrznych)
                const imageA = q.imageA || '';
                const imageB = q.imageB || '';
                
                console.log('🖼️ HOT_OR_NOT Screen.html - q:', q);
                console.log('🖼️ HOT_OR_NOT Screen.html - q.imageA:', q.imageA, 'q.imageB:', q.imageB);
                
                // Funkcja do wykrywania orientacji obrazka (bardziej precyzyjna)
                function detectImageOrientation(imageSrc, callback) {
                    if(!imageSrc || imageSrc.trim() === '') {
                        callback('square');
                        return;
                    }
                    const img = new Image();
                    img.onload = function() {
                        const ratio = img.width / img.height;
                        // Pionowe: wysokość > szerokość (ratio < 1)
                        if(ratio < 0.9) callback('portrait');
                        // Poziome: szerokość > wysokość (ratio > 1)
                        else if(ratio > 1.1) callback('landscape');
                        // Kwadratowe: prawie równe (0.9 <= ratio <= 1.1)
                        else callback('square');
                    };
                    img.onerror = () => {
                        console.warn('⚠️ Nie można załadować obrazka do wykrycia orientacji:', imageSrc);
                        callback('square');
                    };
                    const fullSrc = imageSrc.startsWith('/') || imageSrc.startsWith('http') ? imageSrc : '/uploads/' + imageSrc;
                    img.src = fullSrc;
                }
                
                // Wykryj orientację obu obrazków
                detectImageOrientation(imageA, (orientA) => {
                    detectImageOrientation(imageB, (orientB) => {
                        let layout = 'horizontal';
                        
                        console.log('🖼️ HOT_OR_NOT - orientacje:', { orientA, orientB });
                        
                        // Jeśli oba są pionowe → układ pionowy (jeden pod drugim)
                        if(orientA === 'portrait' && orientB === 'portrait') {
                            layout = 'vertical';
                        }
                        // Jeśli oba są poziome → układ poziomy (obok siebie)
                        else if(orientA === 'landscape' && orientB === 'landscape') {
                            layout = 'horizontal';
                        }
                        // Mieszane (jeden pionowy, drugi poziomy) → układ mieszany/kwadratowy
                        else if((orientA === 'portrait' && orientB === 'landscape') || 
                                (orientA === 'landscape' && orientB === 'portrait')) {
                            layout = 'mixed';
                        }
                        // Jeśli jeden jest kwadratowy, użyj orientacji drugiego
                        else if(orientA === 'square' && orientB !== 'square') {
                            layout = orientB === 'portrait' ? 'vertical' : 'horizontal';
                        }
                        else if(orientB === 'square' && orientA !== 'square') {
                            layout = orientA === 'portrait' ? 'vertical' : 'horizontal';
                        }
                        // Oba kwadratowe → układ poziomy (domyślny)
                        else {
                            layout = 'horizontal';
                        }
                        
                        console.log('🖼️ HOT_OR_NOT - wybrany layout:', layout);
                        grid.classList.add(`layout-${layout}`);
                        
                        // Renderuj obrazki
                        renderHotOrNotImages();
                    });
                });
                
                function renderHotOrNotImages() {
                    // Popraw ścieżki obrazków - użyj imageA/imageB z pytania
                    let imageASrc = (q.imageA && q.imageA.trim() !== '') ? q.imageA.trim() : '';
                    let imageBSrc = (q.imageB && q.imageB.trim() !== '') ? q.imageB.trim() : '';
                    
                    console.log('🖼️ HOT_OR_NOT - surowe wartości:', {
                        'q.imageA': q.imageA,
                        'q.imageB': q.imageB,
                        'q.imageA type': typeof q.imageA,
                        'q.imageA length': q.imageA ? q.imageA.length : 0,
                        'q.imageB type': typeof q.imageB,
                        'q.imageB length': q.imageB ? q.imageB.length : 0,
                        'q.media': q.media,
                        'q': q
                    });
                    
                    // Jeśli są puste, spróbuj użyć media jako fallback (tylko jeśli media nie jest puste)
                    if(!imageASrc && q.media && q.media.trim() !== '') {
                        imageASrc = q.media.trim();
                        console.log('🖼️ Używam q.media jako fallback dla A:', imageASrc);
                    }
                    if(!imageBSrc && q.media && q.media.trim() !== '') {
                        imageBSrc = q.media.trim();
                        console.log('🖼️ Używam q.media jako fallback dla B:', imageBSrc);
                    }
                    
                    // Dodaj /uploads/ jeśli brakuje (tylko jeśli ścieżka nie jest pusta)
                    // WAŻNE: Sprawdź czy ścieżka już zaczyna się od /uploads/ lub http
                    if(imageASrc && imageASrc.trim() !== '') {
                        if (!imageASrc.startsWith('/') && !imageASrc.startsWith('http')) {
                            imageASrc = '/uploads/' + imageASrc;
                        } else if (imageASrc.startsWith('/uploads/')) {
                            // Już ma prefiks /uploads/, zostaw bez zmian
                            console.log('✅ imageA już ma prefiks /uploads/:', imageASrc);
                        }
                    }
                    if(imageBSrc && imageBSrc.trim() !== '') {
                        if (!imageBSrc.startsWith('/') && !imageBSrc.startsWith('http')) {
                            imageBSrc = '/uploads/' + imageBSrc;
                        } else if (imageBSrc.startsWith('/uploads/')) {
                            // Już ma prefiks /uploads/, zostaw bez zmian
                            console.log('✅ imageB już ma prefiks /uploads/:', imageBSrc);
                        }
                    }
                    
                    console.log('🖼️ HOT_OR_NOT - finalne ścieżki:', {
                        'imageA': imageASrc,
                        'imageB': imageBSrc,
                        'imageA empty': !imageASrc || imageASrc.trim() === '',
                        'imageB empty': !imageBSrc || imageBSrc.trim() === '',
                        'imageA startsWith /uploads/': imageASrc ? imageASrc.startsWith('/uploads/') : false,
                        'imageB startsWith /uploads/': imageBSrc ? imageBSrc.startsWith('/uploads/') : false
                    });
                    
                    // Sprawdź poprawne odpowiedzi
                    let correctAnswers = q.correct;
                    if(correctAnswers === undefined || correctAnswers === null || correctAnswers === -1) {
                        correctAnswers = [];
                    } else if(!Array.isArray(correctAnswers)) {
                        correctAnswers = [correctAnswers];
                    }
                    
                    const isACorrect = correctAnswers.includes(0);
                    const isBCorrect = correctAnswers.includes(1);
                    
                    // Statystyki
                    const statsA = state.stats?.A || 0;
                    const statsB = state.stats?.B || 0;
                    const totalStats = statsA + statsB;
                    const statsHTMLA = state.showStats ? `<div class="hot-image-stats">${statsA}${totalStats > 0 ? ` (${Math.round(statsA/totalStats*100)}%)` : ''}</div>` : '';
                    const statsHTMLB = state.showStats ? `<div class="hot-image-stats">${statsB}${totalStats > 0 ? ` (${Math.round(statsB/totalStats*100)}%)` : ''}</div>` : '';
                    
                    let cardClassA = 'hot-image-card qc-a';
                    let cardClassB = 'hot-image-card qc-b';
                    
                    if(state.showCorrect) {
                        if(isACorrect) cardClassA += ' is-correct';
                        else if(correctAnswers.length > 0) cardClassA += ' is-wrong';
                        
                        if(isBCorrect) cardClassB += ' is-correct';
                        else if(correctAnswers.length > 0) cardClassB += ' is-wrong';
                    }
                    
                    // Renderuj obrazki - tylko img, bez dodatkowych divów
                    const imgAHTML = imageASrc && imageASrc.trim() !== '' ? 
                        `<img src="${imageASrc}" alt="Opcja A" onerror="console.error('❌ Błąd ładowania obrazka A:', this.src); this.style.display='none'; const parent = this.parentElement; if(parent && !parent.querySelector('.no-image-placeholder')) { const placeholder = document.createElement('div'); placeholder.className = 'no-image-placeholder'; placeholder.style.cssText = 'display: flex; align-items: center; justify-content: center; height: 100%; width: 100%; color: rgba(255,255,255,0.5); font-size: 1.5vw; position: absolute; top: 0; left: 0;'; placeholder.textContent = 'Brak obrazka'; parent.appendChild(placeholder); }" onload="console.log('✅ Obrazek A załadowany:', this.src, 'wymiary:', this.naturalWidth, 'x', this.naturalHeight); const placeholder = this.parentElement?.querySelector('.no-image-placeholder'); if(placeholder) placeholder.remove();">` : 
                        `<div class="no-image-placeholder" style="display: flex; align-items: center; justify-content: center; height: 100%; width: 100%; color: rgba(255,255,255,0.5); font-size: 1.5vw; position: absolute; top: 0; left: 0;">Brak obrazka</div>`;
                    
                    const imgBHTML = imageBSrc && imageBSrc.trim() !== '' ? 
                        `<img src="${imageBSrc}" alt="Opcja B" onerror="console.error('❌ Błąd ładowania obrazka B:', this.src); this.style.display='none'; const parent = this.parentElement; if(parent && !parent.querySelector('.no-image-placeholder')) { const placeholder = document.createElement('div'); placeholder.className = 'no-image-placeholder'; placeholder.style.cssText = 'display: flex; align-items: center; justify-content: center; height: 100%; width: 100%; color: rgba(255,255,255,0.5); font-size: 1.5vw; position: absolute; top: 0; left: 0;'; placeholder.textContent = 'Brak obrazka'; parent.appendChild(placeholder); }" onload="console.log('✅ Obrazek B załadowany:', this.src, 'wymiary:', this.naturalWidth, 'x', this.naturalHeight); const placeholder = this.parentElement?.querySelector('.no-image-placeholder'); if(placeholder) placeholder.remove();">` : 
                        `<div class="no-image-placeholder" style="display: flex; align-items: center; justify-content: center; height: 100%; width: 100%; color: rgba(255,255,255,0.5); font-size: 1.5vw; position: absolute; top: 0; left: 0;">Brak obrazka</div>`;
                    
                    console.log('🖼️ HOT_OR_NOT - renderowanie gridu z obrazkami:', {
                        'imageASrc': imageASrc,
                        'imageBSrc': imageBSrc,
                        'cardClassA': cardClassA,
                        'cardClassB': cardClassB,
                        'answers': answers
                    });
                    
                    grid.innerHTML = `
                        <div class="${cardClassA}">
                            <div class="hot-image-label">A</div>
                            <div class="hot-image-wrapper">
                                ${imgAHTML}
                            </div>
                            <div class="hot-image-answer">${answers[0] || 'Opcja A'}</div>
                            ${statsHTMLA}
                        </div>
                        <div class="${cardClassB}">
                            <div class="hot-image-label">B</div>
                            <div class="hot-image-wrapper">
                                ${imgBHTML}
                            </div>
                            <div class="hot-image-answer">${answers[1] || 'Opcja B'}</div>
                            ${statsHTMLB}
                        </div>
                    `;
                    
                    console.log('✅ HOT_OR_NOT - grid.innerHTML ustawiony, elementy:', grid.children.length);
                    
                    // Upewnij się że kontenery są widoczne po renderowaniu
                    setTimeout(() => {
                        const wrappers = grid.querySelectorAll('.hot-image-wrapper');
                        wrappers.forEach(wrapper => {
                            wrapper.style.display = 'flex';
                            wrapper.style.visibility = 'visible';
                            wrapper.style.opacity = '1';
                            wrapper.style.minHeight = '200px';
                            console.log('✅ Wrapper ustawiony - display:', wrapper.style.display, 'minHeight:', wrapper.style.minHeight);
                        });
                        
                        const images = grid.querySelectorAll('.hot-image-wrapper img');
                        images.forEach(img => {
                            console.log('🖼️ Obrazek w DOM:', {
                                src: img.src,
                                complete: img.complete,
                                naturalWidth: img.naturalWidth,
                                naturalHeight: img.naturalHeight,
                                display: window.getComputedStyle(img).display,
                                visibility: window.getComputedStyle(img).visibility
                            });
                        });
                    }, 100);
                }
                
                // Renderuj od razu (z domyślnym układem, potem zaktualizuje się po wykryciu orientacji)
                renderHotOrNotImages();
            }
            else if(currentMode==='VOTE') {
                // Nie dodawaj run-animation jeśli pokazujemy statystyki lub poprawną odpowiedź (aby nie restartować animacji przy aktualizacji statystyk)
                const shouldAnimate = !state.showStats && !state.showCorrect && state.activeQuestionIndex !== window.lastQIndex;
                grid.className = 'quiz-grid grid-vote-text' + (shouldAnimate ? ' run-animation' : '');
                if(hasImage) {
                    grid.classList.add('has-image');
                    heroContainer.classList.add('vote-mode');
                    contentArea.classList.add('has-vote-image');
                } else {
                    grid.classList.remove('has-image');
                    heroContainer.classList.remove('vote-mode');
                    contentArea.classList.remove('has-vote-image');
                }
            } else {
                // Użyj liczby niepustych odpowiedzi do wyboru gridu
                // Nie dodawaj run-animation jeśli pokazujemy statystyki lub poprawną odpowiedź (aby nie restartować animacji przy aktualizacji statystyk)
                const shouldAnimate = !state.showStats && !state.showCorrect && state.activeQuestionIndex !== window.lastQIndex;
                const gridClass = (answerCount === 4) ? 'quiz-grid grid-4' : 'quiz-grid grid-5';
                grid.className = gridClass + (shouldAnimate ? ' run-animation' : '');
                heroContainer.classList.remove('vote-mode');
                contentArea.classList.remove('has-vote-image');
            }
            
            // Ponowne dodanie klas po czyszczeniu innerHTML
            if(state.showStats) grid.classList.add('show-stats');
            if(state.showCorrect) grid.classList.add('show-correct');

            // Dogrywka TAK/NIE (bez punktów) – wyśrodkowana, z procentami jak w ankiecie
            if(inPlayoff && state.playoff) {
                const p = state.playoff;
                const totalP = (p.stats.A || 0) + (p.stats.B || 0);
                const wA = totalP > 0 ? Math.round((p.stats.A || 0) / totalP * 100) : 50;
                const pctA = totalP > 0 ? Math.round((p.stats.A || 0) / totalP * 100) : 0;
                const pctB = totalP > 0 ? Math.round((p.stats.B || 0) / totalP * 100) : 0;
                grid.innerHTML = `
                    <div class="playoff-screen-grid">
                        <div class="playoff-card playoff-tak" style="flex:${wA};"><div class="playoff-label">TAK</div><div class="playoff-pct">${pctA}%</div><div class="playoff-count">${p.stats.A || 0} głosów</div></div>
                        <div class="playoff-card playoff-nie" style="flex:${100-wA};"><div class="playoff-label">NIE</div><div class="playoff-pct">${pctB}%</div><div class="playoff-count">${p.stats.B || 0} głosów</div></div>
                    </div>
                `;
            }
            // HOT_OR_NOT już został wyrenderowany powyżej - pomiń standardowe renderowanie
            else if(q?.type === 'HOT_OR_NOT') {
                // Już wyrenderowane
            } else if(q?.type === 'ESTIMATION') {
                if (state.showStats || state.showCorrect) {
                    const stats = state.estimationStats || [];
                    const minRange = q.min !== undefined && q.min !== null ? Number(q.min) : 0;
                    const maxRange = q.max !== undefined && q.max !== null ? Number(q.max) : 100;
                    const correctVal = state.estimationCorrectValue != null ? state.estimationCorrectValue : (q.correctValue != null ? Number(q.correctValue) : null);
                    
                    let html = '<div class="estimation-result-box">';
                    
                    if (stats.length > 0) {
                        const estTotal = stats.reduce((s, x) => s + x.count, 0);
                        const maxCount = Math.max(...stats.map(x => x.count), 1);
                        
                        // Grupuj odpowiedzi w przedziały 5% zakresu (dokładność do 5%)
                        const range = maxRange - minRange;
                        const bucketSize = Math.max(1, range * 0.05); // 5% zakresu
                        const buckets = new Map();
                        
                        stats.forEach(item => {
                            // Normalizuj wartość do zakresu [0, range], potem grupuj w przedziały 5%
                            const normalizedValue = item.value - minRange;
                            const bucketIndex = Math.round(normalizedValue / bucketSize);
                            const bucketValue = minRange + (bucketIndex * bucketSize);
                            
                            if (!buckets.has(bucketValue)) {
                                buckets.set(bucketValue, { value: bucketValue, count: 0 });
                            }
                            buckets.get(bucketValue).count += item.count;
                        });
                        
                        const sortedBuckets = Array.from(buckets.values()).sort((a, b) => a.value - b.value);
                        const maxBucketCount = Math.max(...sortedBuckets.map(b => b.count), 1);
                        
                        html += '<div class="estimation-chart-container">';
                        
                        if (state.showCorrect && correctVal !== null && !Number.isNaN(correctVal)) {
                            html += '<div class="estimation-correct-label">Poprawna odpowiedź: <strong>' + correctVal + '</strong></div>';
                        } else {
                            html += '<div class="estimation-correct-label">Odpowiedzi graczy</div>';
                        }
                        
                        // Wykres poziomy
                        html += '<div class="estimation-chart">';
                        html += '<div class="estimation-chart-labels">';
                        html += '<span class="chart-label-min">' + minRange + '</span>';
                        html += '<span class="chart-label-max">' + maxRange + '</span>';
                        html += '</div>';
                        
                        html += '<div class="estimation-chart-track">';
                        
                        // Linia pozioma (suwak)
                        html += '<div class="estimation-chart-line"></div>';
                        
                        // Prawidłowa odpowiedź - marker
                        if (state.showCorrect && correctVal !== null && !Number.isNaN(correctVal) && correctVal >= minRange && correctVal <= maxRange) {
                            const correctPos = ((correctVal - minRange) / range) * 100;
                            html += '<div class="estimation-correct-marker" style="left: ' + correctPos + '%;"></div>';
                        }
                        
                        // Słupki dla każdego przedziału
                        sortedBuckets.forEach(bucket => {
                            // Oblicz pozycję względem zakresu [minRange, maxRange]
                            let pos = 0;
                            if (range > 0) {
                                pos = ((bucket.value - minRange) / range) * 100;
                            }
                            // Ogranicz pozycję do zakresu [0, 100]
                            pos = Math.max(0, Math.min(100, pos));
                            
                            const height = Math.max(20, (bucket.count / maxBucketCount) * 150); // Min 20px, max 150px
                            const pct = estTotal > 0 ? Math.round((bucket.count / estTotal) * 100) : 0;
                            
                            // Zaokrąglij wartość do czytelności
                            const displayValue = Math.round(bucket.value * 10) / 10;
                            
                            html += '<div class="estimation-bar" style="left: ' + pos + '%; height: ' + height + 'px;" title="' + displayValue + ': ' + bucket.count + ' (' + pct + '%)">';
                            html += '<div class="estimation-bar-value">' + displayValue + '</div>';
                            html += '<div class="estimation-bar-count">' + bucket.count + '</div>';
                            html += '</div>';
                        });
                        
                        html += '</div>'; // estimation-chart-track
                        html += '</div>'; // estimation-chart
                        html += '</div>'; // estimation-chart-container
                    } else {
                        html += '<div style="color: rgba(255,255,255,0.6); text-align: center; padding: 20px;">Brak odpowiedzi</div>';
                    }
                    html += '</div>';
                    grid.innerHTML = html;
                } else {
                    grid.innerHTML = '<div class="estimation-screen-msg">📐 Gracze wpisują liczbę na telefonach</div>';
                }
            } else if(q?.type === 'OPEN' || q?.type === 'LETTER') {
                // WAŻNE: Pokazuj chmurę słów nawet gdy istnieje dogrywka (ale nie jest aktywna)
                // Dogrywkę pokazuj tylko gdy jest aktywna (playoff.active === true)
                const isPlayoffActive = state.playoff && state.playoff.active;
                if(state.openCloud && state.openCloud.length > 0 && !isPlayoffActive) {
                    const maxCount = Math.max(...state.openCloud.map(x => x.count), 1);
                    function esc(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }
                    grid.innerHTML = '<div class="word-cloud">' + state.openCloud.map(item => {
                        const size = Math.max(14, Math.min(72, 14 + (item.count / maxCount) * 58));
                        return `<span class="word-cloud-item" style="font-size:${size}px">${esc(item.word)}</span>`;
                    }).join(' ') + '</div>';
                } else if (!isPlayoffActive) {
                    const msg = q?.type === 'LETTER' ? '🔤 Gracze wpisują wyrazy zaczynające się na przypisane litery na telefonach' : '💬 Gracze wpisują odpowiedzi na telefonach';
                    grid.innerHTML = `<div class="estimation-screen-msg">${msg}</div>`;
                }
                // Jeśli dogrywka jest aktywna, nie pokazuj nic tutaj (dogrywka jest obsługiwana gdzie indziej)
            } else {
                const letters = ['A','B','C','D','E'];
                const colors = ['qc-a','qc-b','qc-c','qc-d','qc-e'];
                // Limit odpowiedzi: dla VOTE zawsze 2, dla QUIZ/MUSIC - wszystkie niepuste odpowiedzi (max 5)
                const limit = (currentMode==='VOTE') ? 2 : Math.min(answerCount, 5);

                // Iteruj przez wszystkie odpowiedzi, ale pokazuj tylko niepuste
                let displayedIndex = 0;
                for(let i=0; i<answers.length && displayedIndex<limit; i++) {
                    // Pomiń puste odpowiedzi
                    if(!answers[i] || answers[i].trim() === '') continue;
                
                let cardClass = 'q-card ' + colors[displayedIndex];
                let width = 0;
                
                // Statystyki - pokazuj zarówno gdy showStats jak i showCorrect (aby nie znikały po pokazaniu poprawnej odpowiedzi)
                // Dla QUIZ i VOTE/VOTE_IMG – pasek procentowy (q-result-bar) i liczba głosów
                if((state.showStats || state.showCorrect) && (currentMode==='QUIZ' || currentMode==='VOTE')) {
                    const total = Object.values(state.stats || {}).reduce((a,b)=>a+b,0);
                    // Użyj oryginalnego indeksu i dla statystyk (serwer wysyła statystyki według oryginalnych indeksów)
                    const letterForStats = letters[i]; // Oryginalny indeks
                    if(total>0) width = ((state.stats[letterForStats]||0)/total)*100;
                }

                if(state.showCorrect) {
                    let corrs = Array.isArray(q?.correct) ? q.correct : [q?.correct];
                    // Sprawdź czy oryginalny indeks i jest poprawny
                    if(corrs.includes(i)) cardClass += ' is-correct';
                    else cardClass += ' is-wrong';
                }

                // Dla statystyk użyj oryginalnego indeksu
                // Pokazuj statystyki zarówno gdy showStats jak i showCorrect (aby nie znikały po pokazaniu poprawnej odpowiedzi)
                const letterForDisplay = letters[displayedIndex]; // Indeks wyświetlania (A, B, C, D, E)
                const letterForStats = letters[i]; // Oryginalny indeks dla statystyk
                const totalForPct = Object.values(state.stats || {}).reduce((a,b)=>a+b,0);
                const countHTML = ((state.showStats || state.showCorrect) && (currentMode==='QUIZ' || currentMode==='VOTE')) ? 
                    `<div style="z-index:100; font-size: 5vw !important; font-weight:900; margin-left:auto; text-shadow:0 2px 5px #000; color:white">${state.stats[letterForStats]||0} <span style="font-size:0.7em;opacity:0.9">(${totalForPct>0 ? Math.round(((state.stats[letterForStats]||0)/totalForPct)*100) : 0}%)</span></div>` : '';

                grid.innerHTML += `
                    <div class="${cardClass}">
                        <div class="q-result-bar" style="width:${width}%"></div>
                        <div class="q-letter">${letterForDisplay}</div>
                        <div class="q-text">${answers[i]}</div>
                        ${countHTML}
                    </div>
                `;
                
                    displayedIndex++;
                }
            }

            // TIMER / AUDIO – tylko w czasie pytań
            // Timer badge - pokazuj TYLKO gdy:
            // 1. Jest pytanie (q istnieje)
            // 2. Nie pokazujemy statystyk ani poprawnej odpowiedzi
            // 3. Jest czas (timeLeft > 0 i duration > 0)
            // 4. Czas nie jest wyłączony (disableTimePoints !== true)
            // 5. Typ stanu to GAME (nie PODIUM, nie IDLE, nie INTRO)
            const timerBadge = document.getElementById('timer-badge');
            const timeLeftEl = document.getElementById('time-left');
            // Dla typu LETTER timer pokazuj tylko gdy gra się rozpoczęła (litery zostały wysłane)
            const letterGameStarted = q && q.type === 'LETTER' && state.letterGame && state.letterGame.gameStarted;
            const shouldShowTimer = state.type === 'GAME' && 
                                    !inPlayoff &&
                                    !state.showStats && 
                                    !state.showCorrect && 
                                    q && 
                                    q.type !== 'SHIPS' && // NIE pokazuj timera dla pytań SHIPS
                                    (q.type !== 'LETTER' || letterGameStarted) && // Dla LETTER tylko gdy gra się rozpoczęła
                                    state.timeLeft > 0 && 
                                    state.duration > 0 &&
                                    !(state.quizOptions && state.quizOptions.disableTimePoints);
            
            // Debug dla typu LETTER
            if(q && q.type === 'LETTER') {
                console.log('🔤 LETTER timer check:', {
                    type: state.type,
                    inPlayoff: inPlayoff,
                    showStats: state.showStats,
                    showCorrect: state.showCorrect,
                    timeLeft: state.timeLeft,
                    duration: state.duration,
                    disableTimePoints: state.quizOptions && state.quizOptions.disableTimePoints,
                    shouldShowTimer: shouldShowTimer
                });
            }
            
            // WAŻNE: Dla pytań muzycznych dźwięk jest już odtwarzany w sekcji "NOWE PYTANIE - DETEKCJA" powyżej
            // Tutaj tylko logujemy dla debugowania
            const currentQuestionId = q?.id !== undefined && q?.id !== null ? q.id : `q_${state.activeQuestionIndex || 0}`;
            const isNewQuestion = currentQuestionId !== lastQuestionId;
            
            console.log('🔍 DEBUG Screen.html - sprawdzanie odtwarzania dźwięku (po sekcji NOWE PYTANIE):', {
                questionType: q?.type,
                hasAudio: !!q?.audio,
                audioUrl: q?.audio,
                currentQuestionId: currentQuestionId,
                lastQuestionId: lastQuestionId,
                isNewQuestion: isNewQuestion,
                stateType: state.type,
                shouldShowTimer: shouldShowTimer,
                note: 'Dźwięk muzyczny powinien być już odtworzony w sekcji NOWE PYTANIE powyżej'
            });
            
            if(shouldShowTimer) {
                // Pokaż timer badge i rozpocznij odliczanie
                timerBadge.style.display = 'block';
                const left = Number(state.timeLeft || 0);
                const total = Number(state.duration || left || 30);
                startTimerBadge(left, total);
                
                // Odtwarzaj audio tylko dla nowego pytania, nie przy każdej aktualizacji stanu
                // (ale tylko jeśli nie jest to pytanie muzyczne - już obsłużone wyżej)
                if(q && q.audio && isNewQuestion && q.type !== 'MUSIC') {
                    playMusic(q.audio);
                }
                startTimer(left, total, !!q.audio);
            } else {
                // Aktualizuj timer z wartością serwera nawet gdy nie pokazujemy timera (dla synchronizacji)
                if (state.timeLeft !== undefined && state.timeLeft !== null && q && q.type !== 'SHIPS') {
                    updateTimerFromServer(state.timeLeft);
                }
                // Ukryj timer badge
                timerBadge.style.display = 'none';
                clearInterval(timerBadgeInterval);
                clearInterval(timerInt);
                document.getElementById('timer-circle').style.display='none';
                clockPlayer.pause();
            }
        });

        // ========================
        // TIMER BADGE (jak w vote.html)
        // ========================
        function startTimerBadge(seconds, total) {
            clearInterval(timerBadgeInterval);
            const display = document.getElementById('time-left');
            const end = Date.now() + seconds * 1000;
            
            display.classList.remove('warning');
            
            // Aktualizuj od razu
            const updateDisplay = () => {
                const diff = Math.ceil((end - Date.now()) / 1000);
                if(diff <= 0) {
                    display.textContent = '0';
                    display.classList.add('warning');
                    clearInterval(timerBadgeInterval);
                    return;
                }
                
                display.textContent = diff;
                
                if(diff <= 5) {
                    display.classList.add('warning');
                } else {
                    display.classList.remove('warning');
                }
            };
            
            updateDisplay(); // Pierwsza aktualizacja od razu
            
            timerBadgeInterval = setInterval(updateDisplay, 1000);
        }
        
        // ========================
        // TIMER (okrągły SVG)
        // ========================
        function startTimer(left, total, hasMusic) {
            clearInterval(timerInt);
            // Nie pokazuj starego kołowego timera - używamy tylko badge
            const oldTimer = document.getElementById('timer-circle');
            if(oldTimer) {
                oldTimer.style.display = 'none';
                oldTimer.style.visibility = 'hidden';
            }
            const end = Date.now() + left*1000;
            
            timerInt = setInterval(()=>{
                const diff = (end - Date.now())/1000;
                
                if(!hasMusic && sfxPlayer.paused && clockPlayer.paused && diff>0) {
                    playClock();
                }

                if(diff<=0) {
                    clearInterval(timerInt);
                    document.getElementById('timer-val').innerText = '0';
                    return;
                }

                document.getElementById('timer-val').innerText = Math.ceil(diff);
                document.getElementById('timer-path').style.strokeDashoffset = 283 - (283*(diff/total));
            }, 50);
        }

        // ========================
        // CONFETTI
        // ========================
        function showConfetti(place) {
            const colors = ['#FFD700','#FF6B6B','#4ECDC4','#45B7D1','#FFA07A','#98D8C8','#F7DC6F','#BB8FCE'];
            const confettiContainer = document.getElementById('confetti-container');
            confettiContainer.innerHTML = '';
            
            // Wszystkie miejsca mają confetti przez około 5 sekund
            const duration = 5000; // 5 sekund dla wszystkich miejsc
            let count, size;
            if(place===3) { count=50; size={min:8, max:15}; }
            else if(place===2) { count=100; size={min:10, max:18}; }
            else if(place===1) { count=200; size={min:12, max:25}; }

            for(let i=0; i<count; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random()*100 + '%';
                confetti.style.backgroundColor = colors[Math.floor(Math.random()*colors.length)];
                confetti.style.width = (Math.random()*(size.max - size.min) + size.min) + 'px';
                confetti.style.height = confetti.style.width;
                confetti.style.animationDelay = Math.random()*0.5 + 's';
                // Animacja trwa około 5 sekund (dla wszystkich miejsc)
                confetti.style.animationDuration = '5s';
                confettiContainer.appendChild(confetti);
            }
            // Wyczyść confetti po około 5.5 sekundy (dodatkowy czas na opadanie ostatnich elementów)
            setTimeout(() => { confettiContainer.innerHTML = ''; }, duration+500);
        }

        // === GRA W STATKI ===
        let shipsGameState = null;
        let currentGameState = null; // Przechowuj aktualny stan gry

        function renderShipsBoard(q, state) {
            if (!q || q.type !== 'SHIPS') return;
            
            const grid = document.getElementById('quiz-grid');
            if (!grid) return;
            
            // WAŻNE: Zmień display na block aby uniknąć konfliktu z display: grid
            // To zapewnia że flex layout wewnątrz działa poprawnie przy pierwszym renderowaniu
            // Ustaw style inline z !important aby nadpisać wszystkie CSS reguły
            grid.style.cssText = 'display: block !important; width: 100% !important; flex: 1 !important; min-height: 0 !important; overflow: auto !important;';
            // Usuń klasy które mogą powodować konflikty z display: grid
            grid.className = 'quiz-grid ships-mode';
            
            const boardSize = q.boardSize || 8;
            const ships = q.ships || [];
            
            // Pobierz stan gry statków z serwera
            if (state.shipsGame) {
                // WAŻNE: Zawsze aktualizuj shipsGameState z state.shipsGame gdy jest dostępne
                shipsGameState = {
                    questionId: state.shipsGame.questionId || q.id,
                    boardSize: state.shipsGame.boardSize || boardSize,
                    ships: state.shipsGame.ships || ships,
                    shots: state.shipsGame.shots || {},
                    currentTurn: state.shipsGame.currentTurn !== undefined ? state.shipsGame.currentTurn : (shipsGameState ? shipsGameState.currentTurn : 0),
                    playersShot: state.shipsGame.playersShot || [],
                    gameEnded: state.shipsGame.gameEnded || false,
                    playerStats: state.shipsGame.playerStats || {}
                };
                console.log('⚓ renderShipsBoard - zaktualizowano shipsGameState z state.shipsGame:', {
                    currentTurn: shipsGameState.currentTurn,
                    showStats: state.showStats,
                    showCorrect: state.showCorrect
                });
            } else {
                // Inicjalizuj jeśli nie ma stanu (tylko jeśli shipsGameState nie istnieje)
                if (!shipsGameState) {
                    shipsGameState = {
                        questionId: q.id,
                        boardSize: boardSize,
                        ships: ships,
                        shots: {},
                        currentTurn: 0,
                        playersShot: [],
                        gameEnded: false,
                        playerStats: {}
                    };
                    console.log('⚓ renderShipsBoard - inicjalizacja shipsGameState');
                } else {
                    // Zachowaj istniejący stan jeśli state.shipsGame nie jest dostępne
                    console.log('⚓ renderShipsBoard - zachowano istniejący shipsGameState (brak state.shipsGame)');
                }
            }
            
            const LETTERS = ['A','B','C','D','E','F','G','H','I','J'];
            
            // Poprawione skalowanie - uwzględnij miejsce na statystyki po prawej stronie
            // WAŻNE: Użyj rzeczywistej wysokości nagłówka zamiast procentowej
            const headerEl = document.querySelector('.header');
            const headerHeight = headerEl ? headerEl.offsetHeight : window.innerHeight * 0.15;
            const padding = 8; // Zmniejszony padding aby uniknąć obcinania
            const gap = 25; // Odstęp między planszą a statystykami
            const statsWidth = 420; // Zwiększona szerokość sekcji statystyk (z napisem "Runda X")
            
            // WAŻNE: Header ma box-shadow: 0 10px 30px który rzuca cień w dół
            // Cień ma offset 10px + blur 30px = około 40px dodatkowej przestrzeni która może zasłaniać planszę
            // Używamy większego marginesu aby zapewnić że plansza się zmieści
            const headerShadowOffset = 15; // Margines na cień header (10px offset + 5px bezpieczeństwa)
            
            // Oblicz dostępną przestrzeń - uwzględnij rzeczywistą wysokość nagłówka, padding i cień
            // WAŻNE: Uwzględnij padding górny i dolny oraz margines na cień
            // Dodatkowo zmniejsz dostępną przestrzeń o 10% aby zapewnić marginesy bezpieczeństwa
            const extraMargin = 10; // Zwiększony margines bezpieczeństwa na dole
            const safetyMargin = Math.floor((window.innerHeight - headerHeight) * 0.05); // 5% dodatkowego marginesu
            const availableHeight = Math.max(100, window.innerHeight - headerHeight - (padding * 2) - extraMargin - headerShadowOffset - safetyMargin);
            const availableWidth = Math.max(100, window.innerWidth - (padding * 2));
            
            // Oblicz dostępną szerokość dla planszy (cała szerokość minus miejsce na statystyki i gap)
            const boardAvailableWidth = availableWidth - statsWidth - gap;
            
            // Rozmiar planszy = boardSize + 1 (dla nagłówków wierszy/kolumn)
            const cellsInBoard = boardSize + 1;
            
            // Oblicz maksymalny rozmiar komórki na podstawie dostępnej wysokości
            // WAŻNE: Użyj Math.floor aby upewnić się że plansza się zmieści
            const maxCellSizeFromHeight = Math.floor(availableHeight / cellsInBoard);
            
            // Oblicz maksymalny rozmiar komórki na podstawie dostępnej szerokości dla planszy
            const maxCellSizeFromWidth = Math.floor(boardAvailableWidth / cellsInBoard);
            
            // Użyj mniejszej wartości aby wszystko się zmieściło
            // Minimalny rozmiar komórki zależy od rozmiaru planszy (mniejsze plansze mogą mieć większe komórki)
            const minCellSize = boardSize <= 6 ? 30 : (boardSize <= 8 ? 25 : 20);
            
            // Oblicz wstępny rozmiar komórki
            let cellSize = Math.max(minCellSize, Math.min(maxCellSizeFromHeight, maxCellSizeFromWidth));
            
            // WAŻNE: Sprawdź czy plansza się zmieści - jeśli nie, zmniejsz cellSize
            // boardTotalSize = cellsInBoard * cellSize musi być <= availableHeight
            let boardTotalSize = cellsInBoard * cellSize;
            if (boardTotalSize > availableHeight) {
                // Jeśli plansza jest za duża, przelicz cellSize na podstawie dostępnej wysokości
                cellSize = Math.floor(availableHeight / cellsInBoard);
                boardTotalSize = cellsInBoard * cellSize;
                // Upewnij się że nie jest za małe
                if (cellSize < minCellSize) {
                    cellSize = minCellSize;
                    boardTotalSize = cellsInBoard * cellSize;
                }
            }
            
            // Sprawdź również szerokość
            if (boardTotalSize > boardAvailableWidth) {
                const cellSizeFromWidth = Math.floor(boardAvailableWidth / cellsInBoard);
                if (cellSizeFromWidth < cellSize) {
                    cellSize = Math.max(minCellSize, cellSizeFromWidth);
                    boardTotalSize = cellsInBoard * cellSize;
                }
            }
            
            // WAŻNE: Zmniejsz rozmiar planszy o 10% aby uniknąć obcinania i zapewnić marginesy
            // Dodatkowo upewnij się że plansza nie przekracza dostępnej przestrzeni
            cellSize = Math.floor(cellSize * 0.90);
            boardTotalSize = cellsInBoard * cellSize;
            
            // Ostatnie sprawdzenie - jeśli plansza nadal jest za duża, zmniejsz jeszcze bardziej
            if (boardTotalSize > availableHeight) {
                cellSize = Math.floor(availableHeight / cellsInBoard * 0.90);
                boardTotalSize = cellsInBoard * cellSize;
            }
            if (boardTotalSize > boardAvailableWidth) {
                const cellSizeFromWidth = Math.floor(boardAvailableWidth / cellsInBoard * 0.90);
                if (cellSizeFromWidth < cellSize) {
                    cellSize = Math.max(minCellSize, cellSizeFromWidth);
                    boardTotalSize = cellsInBoard * cellSize;
                }
            }
            
            const showAnswer = state.showCorrect || false;
            const currentTurn = shipsGameState.currentTurn || 0;
            const roundNumber = currentTurn + 1;
            
            // Aktualizuj numer rundy w zależności od showStats
            let roundText = `Runda ${roundNumber}`;
            if (state.showStats) {
                roundText = `Runda ${roundNumber} zakończona`;
            }
            
            // Kontener główny - flexbox poziomy, wyśrodkowany
            // WAŻNE: Użyj max-height aby upewnić się że kontener nie przekroczy dostępnej przestrzeni
            // Dodaj z-index i position relative aby plansza była nad cieniami header
            // Wyśrodkuj całość używając justify-content: center
            let html = `<div class="ships-board-screen" style="width: 100%; height: 100%; max-height: ${availableHeight}px; display: flex; flex-direction: row; align-items: center; justify-content: center; padding: ${padding}px; gap: ${gap}px; box-sizing: border-box; overflow: visible; position: relative; z-index: 20;">`;
            
            // Plansza po lewej stronie - użyj obliczonego rozmiaru, upewnij się że jest kwadratowa
            // WAŻNE: boardTotalSize jest już obliczone powyżej i gwarantuje że plansza się zmieści
            // Oblicz wysokość jednego wiersza (wszystkie wiersze mają taką samą wysokość)
            const rowHeight = cellSize;
            
            // WAŻNE: Dodaj z-index aby plansza była nad cieniami header
            html += `<div style="flex: 0 0 auto; display: flex; justify-content: center; align-items: center; width: ${boardTotalSize}px; height: ${boardTotalSize}px; min-width: ${boardTotalSize}px; min-height: ${boardTotalSize}px; max-width: ${boardTotalSize}px; max-height: ${boardTotalSize}px; overflow: visible; position: relative; z-index: 21;">`;
            html += `<table class="ships-board-table-screen" style="border-collapse: collapse; border: 3px solid #00aaff; background: #000; box-shadow: 0 0 30px rgba(0, 170, 255, 0.5); width: ${boardTotalSize}px; height: ${boardTotalSize}px; table-layout: fixed; display: table; position: relative; z-index: 22;">`;
            
            // Nagłówek kolumn - użyj stałej wysokości dla wiersza
            const cellPercent = (100 / cellsInBoard).toFixed(2);
            const fontSize = Math.max(10, cellSize * 0.35);
            html += `<tr style="height: ${rowHeight}px;">`;
            html += `<th style="width: ${cellPercent}%; height: ${rowHeight}px; border: 2px solid #00aaff; color: #00aaff; font-size: ${fontSize}px; font-weight: bold; background: #001122; padding: 0; box-sizing: border-box; line-height: ${rowHeight}px; vertical-align: middle;"></th>`;
            for(let c = 0; c < boardSize; c++) {
                html += `<th style="width: ${cellPercent}%; height: ${rowHeight}px; border: 2px solid #00aaff; color: #00aaff; font-size: ${fontSize}px; font-weight: bold; background: #001122; padding: 0; box-sizing: border-box; line-height: ${rowHeight}px; vertical-align: middle;">${LETTERS[c]}</th>`;
            }
            html += `</tr>`;
            
            // Wiersze - wszystkie mają taką samą wysokość
            const cellFontSize = Math.max(14, cellSize * 0.55);
            for(let r = 0; r < boardSize; r++) {
                html += `<tr style="height: ${rowHeight}px;">`;
                html += `<th style="width: ${cellPercent}%; height: ${rowHeight}px; border: 2px solid #00aaff; color: #00aaff; font-size: ${fontSize}px; font-weight: bold; background: #001122; padding: 0; box-sizing: border-box; line-height: ${rowHeight}px; vertical-align: middle;">${r + 1}</th>`;
                for(let c = 0; c < boardSize; c++) {
                    const key = `${r}_${c}`;
                    const shot = shipsGameState?.shots?.[key];
                    let cellStyle = `width: ${cellPercent}%; height: ${rowHeight}px; border: 2px solid #00aaff; background: #001122; text-align: center; color: #fff; font-size: ${cellFontSize}px; font-weight: bold; padding: 0; box-sizing: border-box; line-height: ${rowHeight}px; vertical-align: middle;`;
                    
                    // Sprawdź czy jest statek
                    let hasShip = false;
                    let shipSize = 0;
                    for (const ship of ships) {
                        for(let i = 0; i < ship.size; i++) {
                            const sr = ship.row + (ship.vertical ? i : 0);
                            const sc = ship.col + (ship.vertical ? 0 : i);
                            if (sr === r && sc === c) {
                                hasShip = true;
                                shipSize = ship.size;
                                break;
                            }
                        }
                        if (hasShip) break;
                    }
                    
                    if (shot) {
                        if (shot.hit) {
                            cellStyle += 'background: #22aa44; box-shadow: 0 0 20px #22aa44;';
                            html += `<td style="${cellStyle}">${shipSize ? String(shipSize) : '🔥'}</td>`;
                        } else {
                            // Pudło - zawsze pokazuj
                            cellStyle += 'background: #667788; opacity: 0.8;';
                            html += `<td style="${cellStyle}">○</td>`;
                        }
                    } else if (showAnswer && hasShip) {
                        // Pokaż statek jeśli pokazujemy odpowiedź
                        cellStyle += 'background: #0066cc; border: 2px solid #00aaff;';
                        html += `<td style="${cellStyle}">${shipSize}</td>`;
                    } else {
                        html += `<td style="${cellStyle}"></td>`;
                    }
                }
                html += `</tr>`;
            }
            html += `</table>`;
            html += `</div>`; // Zamknij div z planszą
            
            // Statystyki po prawej stronie (zawsze pokazuj, nawet jeśli puste) - szersze pole
            html += `<div style="flex: 0 0 auto; width: ${statsWidth}px; min-width: ${statsWidth}px; display: flex; flex-direction: column; gap: 20px; max-height: 100%; overflow-y: auto;">`;
            
            // Napis "Runda X" na górze lewej strony przy tabeli statystyk, wyrównany do lewej
            const roundColor = state.showStats ? '#ffcc00' : '#00aaff';
            html += `<div style="text-align: left; color: ${roundColor}; font-size: clamp(1.5rem, 3vw, 2rem); font-weight: bold; text-shadow: 0 0 20px rgba(0, 170, 255, 0.8); padding: 12px 20px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border: 2px solid ${roundColor}; box-sizing: border-box; width: 100%;">${roundText}</div>`;
            
            if (state.showStats && shipsGameState?.playerStats) {
                const playerStats = shipsGameState.playerStats;
                const statsArray = Object.values(playerStats).sort((a, b) => (b.hits + b.misses) - (a.hits + a.misses));
                
                html += `<div class="ships-stats-screen" style="width: 100%; padding: 20px; background: rgba(0,0,0,0.5); border-radius: 8px; border: 2px solid #00aaff; box-sizing: border-box;">`;
                html += `<h3 style="color: #00aaff; margin: 0 0 18px 0; text-align: left; font-size: 1.4em;">📊 Statystyki trafień</h3>`;
                html += `<table style="width: 100%; border-collapse: collapse; font-size: 1.05em;">`;
                html += `<tr style="border-bottom: 2px solid #00aaff;"><th style="text-align: left; padding: 12px 8px; color: #00aaff; font-size: 1.15em; font-weight: bold;">Gracz</th><th style="text-align: center; padding: 12px 8px; color: #00aaff; font-size: 1.15em; font-weight: bold;">Trafienia</th><th style="text-align: center; padding: 12px 8px; color: #00aaff; font-size: 1.15em; font-weight: bold;">Pudła</th><th style="text-align: center; padding: 12px 8px; color: #00aaff; font-size: 1.15em; font-weight: bold;">Razem</th></tr>`;
                
                if (statsArray.length === 0) {
                    html += `<tr><td colspan="4" style="padding: 15px; color: rgba(255,255,255,0.5); text-align: center;">Brak trafień</td></tr>`;
                } else {
                    statsArray.forEach(stats => {
                        html += `<tr style="border-bottom: 1px solid rgba(0,170,255,0.3);"><td style="padding: 12px 8px; color: #fff; font-size: 1.1em; word-break: break-word;">${stats.nick}</td><td style="text-align: center; padding: 12px 8px; color: #00ff00; font-size: 1.15em; font-weight: bold;">${stats.hits}</td><td style="text-align: center; padding: 12px 8px; color: #ff0044; font-size: 1.15em;">${stats.misses}</td><td style="text-align: center; padding: 12px 8px; color: #fff; font-size: 1.15em; font-weight: bold;">${stats.hits + stats.misses}</td></tr>`;
                    });
                }
                
                html += `</table></div>`;
            }
            html += `</div>`; // Zamknij div ze statystykami
            html += `</div>`; // Zamknij ships-board-screen
            
            grid.innerHTML = html;
            
            // WAŻNE: Wymuś ponowne zastosowanie stylów po ustawieniu innerHTML
            // Użyj requestAnimationFrame aby upewnić się że DOM jest zaktualizowany
            requestAnimationFrame(() => {
                grid.style.cssText = 'display: block !important; width: 100% !important; flex: 1 !important; min-height: 0 !important; overflow: auto !important;';
                grid.className = 'quiz-grid ships-mode';
            });
            
            // Nasłuchuj aktualizacji stanu gry (tylko raz, nie duplikuj listenerów)
            // Usuń stare listenery jeśli istnieją
            socket.off('ships_game_update');
            socket.on('ships_game_update', (data) => {
                console.log('⚓ Screen.html ships_game_update otrzymane:', {
                    questionId: data.questionId,
                    qId: q.id,
                    currentTurn: data.currentTurn,
                    showStats: data.showStats,
                    showCorrect: data.showCorrect,
                    matches: data.questionId === q.id
                });
                if (data.questionId === q.id) {
                    // Aktualizuj stan lokalnie - upewnij się że shipsGameState istnieje
                    if (!shipsGameState) {
                        shipsGameState = {
                            questionId: q.id,
                            boardSize: q.boardSize || 8,
                            ships: q.ships || [],
                            shots: {},
                            currentTurn: 0,
                            playersShot: [],
                            gameEnded: false,
                            playerStats: {}
                        };
                    }
                    // Aktualizuj dane z serwera
                    const oldTurn = shipsGameState.currentTurn;
                    shipsGameState.shots = data.shots !== undefined ? data.shots : shipsGameState.shots;
                    shipsGameState.currentTurn = data.currentTurn !== undefined ? data.currentTurn : shipsGameState.currentTurn;
                    shipsGameState.gameEnded = data.gameEnded !== undefined ? data.gameEnded : shipsGameState.gameEnded;
                    
                    console.log('⚓ Screen.html - zaktualizowano shipsGameState:', {
                        oldTurn: oldTurn,
                        newTurn: shipsGameState.currentTurn,
                        showStats: data.showStats,
                        showCorrect: data.showCorrect
                    });
                    
                    // WAŻNE: Aktualizuj currentGameState natychmiast
                    if (currentGameState) {
                        if (data.showStats !== undefined) {
                            currentGameState.showStats = data.showStats;
                        }
                        if (data.showCorrect !== undefined) {
                            currentGameState.showCorrect = data.showCorrect;
                        }
                    }
                    
                    // Re-renderuj planszę z aktualnym stanem
                    // WAŻNE: Użyj showStats i showCorrect z danych jeśli są dostępne (dla natychmiastowej aktualizacji)
                    const currentState = currentGameState || state;
                    const updatedState = {
                        ...currentState,
                        shipsGame: shipsGameState,
                        showStats: data.showStats !== undefined ? data.showStats : (currentState ? currentState.showStats : false),
                        showCorrect: data.showCorrect !== undefined ? data.showCorrect : (currentState ? currentState.showCorrect : false)
                    };
                    console.log('⚓ Screen.html - renderowanie planszy z updatedState:', {
                        showStats: updatedState.showStats,
                        showCorrect: updatedState.showCorrect,
                        currentTurn: updatedState.shipsGame?.currentTurn
                    });
                    renderShipsBoard(q, updatedState);
                }
            });
            
            // WAŻNE: Dodaj listener na resize aby plansza się przeskalowywała dynamicznie
            // Usuń stare listenery jeśli istnieją (aby uniknąć duplikatów)
            window.removeEventListener('resize', handleShipsResize);
            window.addEventListener('resize', handleShipsResize);
        }
        
        // Funkcja obsługująca resize dla planszy statków
        let resizeTimeout;
        function handleShipsResize() {
            // Debounce resize events aby uniknąć zbyt częstego renderowania
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const q = currentGameState?.activeQuestion;
                if (q && q.type === 'SHIPS' && currentGameState) {
                    console.log('🔄 Screen.html - resize detected, re-rendering ships board', {
                        windowHeight: window.innerHeight,
                        windowWidth: window.innerWidth,
                        boardSize: q.boardSize
                    });
                    const updatedState = {
                        ...currentGameState,
                        shipsGame: shipsGameState || currentGameState.shipsGame
                    };
                    renderShipsBoard(q, updatedState);
                }
            }, 200); // 200ms debounce
        }
    </script>
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js', { scope: '/' }).catch(function() {});
        }
    </script>
</body>
</html>
